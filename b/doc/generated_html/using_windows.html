<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>B: Windows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">B
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Windows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Windows in <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> are normally instantiated from a nib file, which contains a description of the window and the views it contains. <a class="el" href="classB_1_1Nib.html" title="Helper class for loading nib-based UI. ">Nib</a> files are edited with the standard Interface Builder tool supplied by Apple.</p>
<p>There a number of advantages to using nib files:</p><ul>
<li>I don't have to write a GUI building tool.</li>
<li>It's much more convenient to lay out a window and its views visually than programatically.</li>
<li>Interface Builder is integrated into Apple's tool suite. Xcode and Project Builder both "know" about nib files. Also, AppleGlot &amp; nibtool allow for fairly easy localisation of nib files.</li>
</ul>
<p>There are also some disadvantages:</p><ul>
<li>It makes <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> dependent on Apple's tools.</li>
<li>IB's support for Carbon isn't as good as its support for Cocoa. For example:<ul>
<li>IB doesn't support all Carbon views. The particular views that are supported vary with the target platform. Those that aren't must be instantiated programatically.</li>
<li>Even for the views that it does support, often some view features can't be specified through IB and must therefore be set programatically.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="instantiating"></a>
Instantiating a Window Object</h1>
<p>Creating a window is accomplished by calling a single member function of <a class="el" href="classB_1_1Window.html" title="A Window Manager window. ">Window</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyMakeWindow(<a class="code" href="classB_1_1Nib.html">B::Nib</a>&amp; inNib, <a class="code" href="classB_1_1AEObject.html">B::AEObject</a>* container)</div><div class="line">{</div><div class="line">    <a class="code" href="classB_1_1OSPtr.html">B::OSPtr&lt;WindowRef&gt;</a> winref;</div><div class="line">    MyWindow*           win;</div><div class="line">    </div><div class="line">    boost::tie(winref, win) = B::Window::CreateFromNib&lt;MyWindow&gt;(</div><div class="line">                                  inNib, <span class="stringliteral">&quot;MainWindow&quot;</span>, container);</div><div class="line">    </div><div class="line">    <span class="comment">// Do some processing here ... if an exception occurs, the WindowRef will be </span></div><div class="line">    <span class="comment">// disposed properly.</span></div><div class="line">    </div><div class="line">    win-&gt;Show(<span class="keyword">true</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// Relenquish ownership of the WindowRef.</span></div><div class="line">    winref.<a class="code" href="classB_1_1OSPtr.html#a931d416d80f99efbd93b00c3ae33b84c">release</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="classB_1_1Window.html#a65eb6e48050ba93576baf875901ab7c9" title="Create a window and its views from a nib. ">Window::CreateFromNib()</a> takes a template parameter, <em>WINDOW</em>, which is the C/C++ class to instantiate; it must be <a class="el" href="classB_1_1Window.html" title="A Window Manager window. ">Window</a> or derive from <a class="el" href="classB_1_1Window.html" title="A Window Manager window. ">Window</a>, and must have a public constructor of the following form:</p>
<div class="fragment"><div class="line">WINDOW(WindowRef inWindowRef, AEObject* inContainer); </div></div><!-- fragment --><p>CreateFromNib() returns an <code>std::pair</code>, with the first element holding a smart pointer to a <code>WindowRef</code>, and the second holding a pointer to the <em>WINDOW</em> object. The reason for this is that the window's lifetime is controlled by the smart pointer; one can't destroy a window object by calling <code>operator</code> <code>delete</code> on it. So if an exception after CreateFromNib() returns but before release() is called on the smart pointer, the window will be disposed properly. The second part of the pair (the <em>WINDOW</em> pointer) is there for convenient type-safe access to the window object.</p>
<p>CreateFromNib() also takes two non-template arguments: a <a class="el" href="classB_1_1Nib.html" title="Helper class for loading nib-based UI. ">Nib</a> identifying the nib file from which to read the window definition, and the window's name as set it Interface Builder's main window.</p>
<h1><a class="anchor" id="deleting"></a>
Deleting a Window Object</h1>
<p>Once instantiated, the window object's lifetime is tied to that of its underlying <code>WindowRef</code>. It follows that instances of <a class="el" href="classB_1_1Window.html" title="A Window Manager window. ">Window</a> (or of classes derived from <a class="el" href="classB_1_1Window.html" title="A Window Manager window. ">Window</a>) should never be deleted directly, but rather indirectly by disposing the window. This can be done by calling Window::Close(), or by letting the standard window handler do its thing when the user clicks the close button.</p>
<h1><a class="anchor" id="finding"></a>
Finding Views</h1>
<p>In order to find views at runtime, you need to name them. Views are named by a signature and an ID number. Both values may be set in the Control portion of Interface Builder's Info window. The signature will normally be your application's signature; it allows various software entities (eg a host app and its plugins) to each place views in a window without fear of naming conflicts. The ID is up to you. The important thing is that the signature/ID pair be unique within the window.</p>
<p>Assuming you have filled in the signature and ID fields of your window's views, you can retrieve a window's <a class="el" href="classB_1_1View.html" title="A client&#39;s-eye-view of an HIViewRef. ">View</a> objects like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyGetViews(MyWindow* window)&lt;</div><div class="line">{</div><div class="line">    StaticTextView* staticTextView;</div><div class="line">    </div><div class="line">    staticTextView = window-&gt;FindViewByID&lt;StaticTextView&gt;(kMyStaticTextID);</div><div class="line">}</div></div><!-- fragment --><p>FindView() locates the <code>HIViewRef</code>, extracts its matching <a class="el" href="classB_1_1View.html" title="A client&#39;s-eye-view of an HIViewRef. ">View</a> object (instantiating it if necessary), then downcasts it to the requested type. Exceptions are thrown if the view isn't found, or if the view isn't of the correct type.</p>
<h1><a class="anchor" id="factories"></a>
View Factories</h1>
<p>You may be wondering how <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> "knows" the correct C/C++ type for a given <code>HIViewRef</code>. The answer resides in the <a class="el" href="classB_1_1ViewFactory.html" title="Instantiates subclasses of View that match a given HIViewRef. ">ViewFactory</a> class. This class manages a set of triples <em>&lt;ControlKind, HIViewID, FactoryProc&gt;</em>. <code>ControlKind</code> identifies the type of view, eg push button, scroll bar, etc. <code>HIViewID</code> identifies a particular view within a window. Finally, <code>FactoryProc</code> is a function that instantiates a C/C++ object (derived from <a class="el" href="classB_1_1View.html" title="A client&#39;s-eye-view of an HIViewRef. ">View</a>) appropriate for the <code>ControlKind</code> / <code>HIViewID</code> pair.</p>
<p>There is a default view factory which contains application-wide triples. This factory is populated during application initialisation to contain entries for known HIToolbox views, eg push button.</p>
<p>When a window object is instantiated by <a class="el" href="classB_1_1Window.html#a65eb6e48050ba93576baf875901ab7c9" title="Create a window and its views from a nib. ">Window::CreateFromNib()</a>, its HIView hierarchy is traversed and for each the view factory is called to instantiate an object of the correct C/C++ type. Thus by the time CreateFromNib() returns, the <a class="el" href="classB_1_1View.html" title="A client&#39;s-eye-view of an HIViewRef. ">View</a> objects for each of the window's HIViews have already been created.</p>
<h1><a class="anchor" id="nib_tips"></a>
Nib Tips</h1>
<p>Here are a number of nib-related gotcha's that the author learned the hard way.</p>
<ul>
<li>When creating windows, always turn on the "Standard handler" check box. It implements a lot of the default behaviour for windows.</li>
<li>Most of the time, you'll want to turn on compositing. Compositing gives your window a true hierarchy of views, makes updates much more efficient, and allows refreshes to occur from within a mouse-tracking loop. Certain types of windows such as drawers require compositing. However, there may be times where you must turn off compositing. For example, the data browser control didn't support composited windows prior to Panther. If you have a data browser in your window and you need to support Jaguar, you will have to turn it off.</li>
<li>Most system-supplied views support both composited and non-composited windows. However, there are exceptions. Some views require composited windows (eg HIScrollView), whereas others require non-composited windows (eg non-Unicode edit text control, pre-Panther data browser).</li>
<li>If you are creating a placeholder window whose contents will be inserted into a Nav dialog, be very careful which views you put into it. Nav dialogs are non-composited in Jaguar and composited in Panther. If you need to support both system releases, avoid controls which require one or the other. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
