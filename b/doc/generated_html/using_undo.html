<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>B: Supporting Undo</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">B
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Supporting <a class="el" href="classB_1_1Undo.html" title="Client interface to the Undo mechanism. ">Undo</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Table of Contents:</p><ul>
<li><a class="el" href="using_undo.html#undo_policies">Undo Policies</a></li>
<li><a class="el" href="using_undo.html#undo_actions">Undoable Actions</a></li>
<li><a class="el" href="using_undo.html#undo_action_groups">Undo Action Groups</a><ul>
<li><a class="el" href="using_undo.html#nested_groups">Nested Groups</a></li>
</ul>
</li>
<li><a class="el" href="using_undo.html#undo_action_class">Class UndoAction</a></li>
<li><a class="el" href="using_undo.html#policy_coupling">Coupling Between Undo Policy and Undo Actions</a></li>
</ul>
<p>Implementing Undo/Redo (henceforth referred to generically as undo) using the <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> framework involves some work at a very high level, and other work at a low level. This article covers both aspects.</p>
<h1><a class="anchor" id="undo_policies"></a>
Undo Policies</h1>
<p>The first thing to do when adding Undo support to an application is to decide what undo policy will be used. What's an undo policy? It's an object that implements a specific level of Undo support.</p>
<p><a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> provides three undo policies:</p>
<ul>
<li><a class="el" href="classB_1_1NullUndoPolicy.html" title="Do-nothing undo policy. ">NullUndoPolicy</a>. This is a do-nothing policy. It's the policy to use when you don't wan't any Undo support.</li>
<li><a class="el" href="classB_1_1SingleUndoPolicy.html" title="Single undo policy. ">SingleUndoPolicy</a>. This supports old-style 1-level deep Undo. Just like MacWrite 1.0.</li>
<li><a class="el" href="classB_1_1MultipleUndoPolicy.html" title="Multiple undo policy. ">MultipleUndoPolicy</a>. This supports an arbitrary number of undos and redos.</li>
</ul>
<p>Although these classes aren't related by inheritance, they are in a sense related because they implement the interface specified in <a class="el" href="classB_1_1UNDO__POLICY.html" title="Template for an Undo Policy class. ">UNDO_POLICY</a>. <a class="el" href="classB_1_1UNDO__POLICY.html" title="Template for an Undo Policy class. ">UNDO_POLICY</a> specifies the member signatures required in order for a class to be usable as an undo policy object.</p>
<p>In <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a>, undo policy objects are used as template parameters. At present there are two classes which take an <a class="el" href="classB_1_1UNDO__POLICY.html" title="Template for an Undo Policy class. ">UNDO_POLICY</a> template parameter:</p>
<ul>
<li><a class="el" href="classB_1_1Application.html" title="The application object. ">Application</a>. The application object may be the locus of Undo support in either simple applications that don't use documents, or very complex ones that allow application-wide Undo (i.e., performing 2 actions in 2 different documents, then doing Undo twice, will undo the action in each document). <a class="el" href="classB_1_1Application.html" title="The application object. ">Application</a>'s class declaration looks like this: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;..., <span class="keyword">class </span>UNDO_POLICY, ...&gt;  <span class="keyword">class </span>Application ... {};</div></div><!-- fragment --> So instantiating <a class="el" href="classB_1_1Application.html" title="The application object. ">Application</a> different undo policy classes will give you varying levels of undo support: <div class="fragment"><div class="line">Application&lt;..., NullUndoPolicy, ...&gt;     <span class="comment">// No undo support</span></div><div class="line">Application&lt;..., SingleUndoPolicy, ...&gt;   <span class="comment">// 1-level-deep undo support, app-wide</span></div><div class="line">Application&lt;..., MultipleUndoPolicy, ...&gt; <span class="comment">// arbitrary-depth undo support, app-wide</span></div></div><!-- fragment --></li>
<li><a class="el" href="classB_1_1Document.html" title="A concrete Document class. ">Document</a>. This is the most interesting one. Documents are usually the locus of Undo support, so it's natural that each document object have an associated undo policy object. <a class="el" href="classB_1_1Document.html" title="A concrete Document class. ">Document</a>'s class declaration looks like this: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class </span>UNDO_POLICY, ...&gt;  <span class="keyword">class </span>Document ... {};</div></div><!-- fragment --> As with <a class="el" href="classB_1_1Application.html" title="The application object. ">Application</a>, instantiating <a class="el" href="classB_1_1Document.html" title="A concrete Document class. ">Document</a> with different undo policy classes will give you varying levels of undo support: <div class="fragment"><div class="line">Document&lt;NullUndoPolicy, ...&gt;     <span class="comment">// No undo support</span></div><div class="line">Document&lt;SingleUndoPolicy, ...&gt;   <span class="comment">// 1-level-deep undo support, per document</span></div><div class="line">Document&lt;MultipleUndoPolicy, ...&gt; <span class="comment">// arbitrary-depth undo support, per document</span></div></div><!-- fragment --></li>
</ul>
<p>So, with these two class templates, one can imagine a number of combinations:</p>
<ul>
<li>For applications without any undo support whatsoever, use <a class="el" href="classB_1_1NullUndoPolicy.html" title="Do-nothing undo policy. ">NullUndoPolicy</a> for both the document and application classes.</li>
<li>For document-centric undo, use <a class="el" href="classB_1_1SingleUndoPolicy.html" title="Single undo policy. ">SingleUndoPolicy</a> or <a class="el" href="classB_1_1MultipleUndoPolicy.html" title="Multiple undo policy. ">MultipleUndoPolicy</a> for the document class and <a class="el" href="classB_1_1NullUndoPolicy.html" title="Do-nothing undo policy. ">NullUndoPolicy</a> for the application class.</li>
<li>For application-wide undo, use <a class="el" href="classB_1_1SingleUndoPolicy.html" title="Single undo policy. ">SingleUndoPolicy</a> or <a class="el" href="classB_1_1MultipleUndoPolicy.html" title="Multiple undo policy. ">MultipleUndoPolicy</a> for the application class.</li>
</ul>
<h1><a class="anchor" id="undo_actions"></a>
Undoable Actions</h1>
<p>Once the undo policy has been decided upon, almost all undo-related development effort revolves around undo actions. Undo actions are "recorded" by the undo machinery (the undo policy object, ultimately) for later execution. They typically store state which is restored at execution time.</p>
<p>Here's a simple example that changes a member variable called <code>mThingy:</code> </p>
<div class="fragment"><div class="line"><span class="comment">// ### INCOMPLETE EXAMPLE ###</span></div><div class="line"><span class="keywordtype">void</span> MyClass::MyUndoableSetThingy(<span class="keywordtype">int</span> inNewThingy)</div><div class="line">{</div><div class="line">    <a class="code" href="classB_1_1AutoUndo.html">B::AutoUndo</a> undo(...);</div><div class="line">    </div><div class="line">    <span class="comment">// Creates an undo action that will be invoked when the user does Undo.  This </span></div><div class="line">    <span class="comment">// function will be called with the old value of mThingy.</span></div><div class="line">    undo.Add(boost::bind(&amp;MyClass::MyUndoableSetThingy, <span class="keyword">this</span>, mThingy));</div><div class="line">    </div><div class="line">    MySetThingy(inNewThingy);</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// A very simple &quot;setter&quot; function.</span></div><div class="line"><span class="keywordtype">void</span> MyClass::MySetThingy(<span class="keywordtype">int</span> inNewThingy)</div><div class="line">{</div><div class="line">    mThingy = inNewThingy;</div><div class="line">}</div></div><!-- fragment --><p>A typical usage scenario would be:</p>
<ol type="1">
<li>The user performs an action that causes <code>MyUndoableSetThingy()</code> to be called.</li>
<li>An undo action is recorded. The action will call <code>MyUndoableSetThingy()</code> with the current value of <code>mThingy</code>.</li>
<li>The value of <code>mThingy</code> is changed to the new value.</li>
<li>Some time later, the user does Undo.</li>
<li>The undo machinery executes the recorded undo action, which calls <code>MyUndoableSetThingy()</code> with (what is now) the old value of <code>mThingy</code>.</li>
<li>A new undo action is recorded. The action will call <code>MyUndoableSetThingy()</code> with the current value of <code>mThingy</code>.</li>
<li>The value of <code>mThingy</code> is changed to the old value.</li>
<li>Some time later, the user does Redo.</li>
<li>etc.</li>
</ol>
<h1><a class="anchor" id="undo_action_groups"></a>
Undo Action Groups</h1>
<p>The example in the preceding section is sufficient for simple cases. Often however, user-triggered actions can modify an application's state in complex ways. Ways which aren't amenable to encapsulation in a single member function. That's where undo action groups come in.</p>
<p>Undo action groups, as the name implies, group together an ordered collection of undo actions. Furthermore, these groups are named; the name is used to fill in the text of the Undo menu item. When a user issues an Undo or Redo command, all of the actions in the group are executed in a LIFO manner.</p>
<p>To use action groups, one begins by "opening" a group. Once a group is opened, any number of undo actions can be added to it. After all of the actions are added, the group needs to be closed. This can be done in one of two ways. The usual way is to "commit" the group. This closes the group and makes it available to the user as an Undo or Redo menu item. The other way is to "abort" the group. This should be called when an exception occurs while a group is open. Aborting a group will cause all previously recorded undo actions to be executed, then the group will be released.</p>
<p>Here's a simple example of using an undo action group:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyUndoableSetThingies(std::vector&lt;MyClass*&gt;&amp; vec, <span class="keywordtype">int</span> inNewThingy)</div><div class="line">{</div><div class="line">    <span class="comment">// Open an undo action group.</span></div><div class="line">    <a class="code" href="classB_1_1AutoUndo.html">B::AutoUndo</a> undo(<a class="code" href="classB_1_1String.html">B::String</a>(<span class="stringliteral">&quot;Change Thingies&quot;</span>));     <span class="comment">// should be localised.</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (std::vector&lt;MyClass*&gt;::iterator it = vec.begin(); </div><div class="line">         it != vec.end(); </div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="comment">// Add the action to the group.</span></div><div class="line">        undo.Add(boost::bind(&amp;MyClass::MySetThingy, *it, inNewThingy));</div><div class="line">        </div><div class="line">        <span class="comment">// Execute the first state change.</span></div><div class="line">        (*it)-&gt;MySetThingy(inNewThingy);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// VERY IMPORTANT:  Commit the group.</span></div><div class="line">    undo.Commit();</div><div class="line">}</div></div><!-- fragment --><p>As you can probably guess, <a class="el" href="classB_1_1AutoUndo.html" title="Automatic management of undo action groups. ">AutoUndo</a> is a helper class whose constructor opens an undo action group. Once opened, actions are added to the group via <code>Add()</code>. Finally, the group is committed prior to returning. This is very important! If <code>Commit()</code> is not called, <a class="el" href="classB_1_1UndoAction.html" title="Abstract base class for undoable actions. ">UndoAction</a>'s destructor will assume an exception has occurred and will abort the group instead of committing it.</p>
<h2><a class="anchor" id="nested_groups"></a>
Nested Groups</h2>
<p>In addition to allowing the concatenation of undo actions, undo action groups may also be nested. Each nesting level gets its own name; however, only the top-most group's name is used in the Undo menu item text.</p>
<p>The previous example could easily be rewritten to use nesting:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyUndoableSetThingies(std::vector&lt;MyClass*&gt;&amp; vec, <span class="keywordtype">int</span> inNewThingy)</div><div class="line">{</div><div class="line">    <span class="comment">// Open an undo action group.</span></div><div class="line">    <a class="code" href="classB_1_1AutoUndo.html">B::AutoUndo</a> undo(<a class="code" href="classB_1_1String.html">B::String</a>(<span class="stringliteral">&quot;Change Thingies&quot;</span>));     <span class="comment">// should be localised.</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (std::vector&lt;MyClass*&gt;::iterator it = vec.begin(); </div><div class="line">         it != vec.end(); </div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">        <span class="comment">// Add an undo action &amp; perform the state change.</span></div><div class="line">        (*it)-&gt;MyUndoableSetThingy(inNewThingy);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// VERY IMPORTANT:  Commit the group.</span></div><div class="line">    undo.Commit();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyClass::MyUndoableSetThingy(<span class="keywordtype">int</span> inNewThingy)</div><div class="line">{</div><div class="line">    <a class="code" href="classB_1_1AutoUndo.html">B::AutoUndo</a> undo(<a class="code" href="classB_1_1String.html">B::String</a>(<span class="stringliteral">&quot;Change Thingy&quot;</span>));       <span class="comment">// should be localised.</span></div><div class="line">    </div><div class="line">    <span class="comment">// Creates an undo action that will be invoked when the user does Undo.  This </span></div><div class="line">    <span class="comment">// function will be called with the old value of mThingy.</span></div><div class="line">    undo.Add(boost::bind(&amp;MyClass::MyUndoableSetThingy, <span class="keyword">this</span>, mThingy));</div><div class="line">    </div><div class="line">    <span class="comment">// No need for MySetThingy() any more.</span></div><div class="line">    mThingy = inNewThingy;</div><div class="line">    </div><div class="line">    <span class="comment">// VERY IMPORTANT:  Commit the group.</span></div><div class="line">    undo.Commit();</div><div class="line">}</div></div><!-- fragment --><p>This version is an improvement over the previous one, because (1) it's shorter, and especially (2) the code to add the undo action and to change the object state is in a single function. That means the function could be implemented in an atomic manner (i.e. either both the undo action addition and the state change succeed, or both fail). Also, both <code>MyClass::MyUndoableSetThingy()</code> and <code>MyUndoableSetThingies()</code> can be invoked directly from UI code, and their undo support will function properly.</p>
<p>By using an STL algorithm, the code can be made even shorter:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyUndoableSetThingies(std::vector&lt;MyClass*&gt;&amp; vec, <span class="keywordtype">int</span> inNewThingy)</div><div class="line">{</div><div class="line">    <span class="comment">// Open an undo action group.</span></div><div class="line">    <a class="code" href="classB_1_1AutoUndo.html">B::AutoUndo</a> undo(<a class="code" href="classB_1_1String.html">B::String</a>(<span class="stringliteral">&quot;Change Thingies&quot;</span>));     <span class="comment">// should be localised.</span></div><div class="line">    </div><div class="line">    <span class="comment">// Add an undo action &amp; perform the state change for each object.</span></div><div class="line">    std::for_each(vec.begin(), vec.end(), </div><div class="line">                  boost::bind(&amp;MyClass::MyUndoableSetThingy, _1, inNewThingy));</div><div class="line">    </div><div class="line">    <span class="comment">// VERY IMPORTANT:  Commit the group.</span></div><div class="line">    undo.Commit();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="undo_action_class"></a>
Class UndoAction</h2>
<p>Until now, the adding of undo actions has been accomplished by passing a <code>boost::bind</code> object to <a class="el" href="classB_1_1AutoUndo.html#ab33a5fceac964bd64acb044b437dd01b" title="Adds inUndoAction to the currently open action group. ">AutoUndo::Add()</a>. This is actually a convenience function. The primitive action addition function takes an object of type <a class="el" href="classB_1_1UndoAction.html" title="Abstract base class for undoable actions. ">UndoAction</a>.</p>
<p>Here is a slightly simplified version of <a class="el" href="classB_1_1UndoAction.html" title="Abstract base class for undoable actions. ">UndoAction</a>'s class declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>UndoAction</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    </div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classB_1_1UndoAction.html#a738ed07cb2f7352f01ef1d7af79794d3">~UndoAction</a>() throw();</div><div class="line">    </div><div class="line">    <span class="comment">// Invocation.  The object should perform its action.</span></div><div class="line">    virtual <span class="keywordtype">void</span>    <a class="code" href="classB_1_1UndoAction.html#ad67a5ed4860f949dbd218db2f28198ed">Perform</a>() = 0;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">protected:</div><div class="line">    </div><div class="line">    <a class="code" href="classB_1_1UndoAction.html#a3975c954d80967c1a7e2075308b678cd">UndoAction</a>();</div><div class="line">};</div></div><!-- fragment --><p>This is an abstract base class, so it can't be instantiated directly. Concrete derivatives must implement <code>Perform()</code> which is the function that does whatever needs to be done.</p>
<p>For example, <code>MyUndoableSetThingy()</code> could be re-implemented to use a custom class derived from <a class="el" href="classB_1_1UndoAction.html" title="Abstract base class for undoable actions. ">UndoAction</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyUndoThingyChange : <span class="keyword">public</span> <a class="code" href="classB_1_1UndoAction.html">B::UndoAction</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">            MyUndoStateChange(MyClass* obj, <span class="keywordtype">int</span> inOldThingy)</div><div class="line">                : mObj(obj), mOldThingy(inOldThingy) {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span>    Perform() { mObj-&gt;MyChangeState(mOldThingy); }</div><div class="line">    </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    </div><div class="line">    MyClass* mObj;</div><div class="line">    <span class="keywordtype">int</span>      mOldThingy;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyClass::MyUndoableSetThingy(<span class="keywordtype">int</span> inNewThingy)</div><div class="line">{</div><div class="line">    <a class="code" href="classB_1_1AutoUndo.html">B::AutoUndo</a> undo(<a class="code" href="classB_1_1String.html">B::String</a>(<span class="stringliteral">&quot;Change Thingy&quot;</span>));       <span class="comment">// should be localised.</span></div><div class="line">    </div><div class="line">    <span class="comment">// Creates an custom undo action that will be invoked when the user does Undo.</span></div><div class="line">    undo.Add(std::auto_ptr&lt;B::UndoAction&gt;(<span class="keyword">new</span> MyUndoThingyChange(<span class="keyword">this</span>, mThingy));</div><div class="line">    </div><div class="line">    MySetThingy(inNewThingy);</div><div class="line">    </div><div class="line">    undo.Commit();</div><div class="line">}</div></div><!-- fragment --><p>This version is equivalent to the first one; obviously it involves a lot more typing! However for certain needs it can make more sense to put undo processing in custom classes.</p>
<p>Note that <a class="el" href="classB_1_1AutoUndo.html#ab33a5fceac964bd64acb044b437dd01b" title="Adds inUndoAction to the currently open action group. ">AutoUndo::Add()</a> is passed an <code>std::auto_ptr&lt;B::UndoAction&gt;</code>, not a pointer to an <a class="el" href="classB_1_1UndoAction.html" title="Abstract base class for undoable actions. ">UndoAction</a>. This makes explicit the fact that the <a class="el" href="classB_1_1AutoUndo.html" title="Automatic management of undo action groups. ">AutoUndo</a> object takes control of the <a class="el" href="classB_1_1UndoAction.html" title="Abstract base class for undoable actions. ">UndoAction</a>'s lifetime.</p>
<h1><a class="anchor" id="policy_coupling"></a>
Coupling Between Undo Policy and Undo Actions</h1>
<p>In all of the preceding examples of undo actions, no mention was made of undo policy objects. This is because the examples used <a class="el" href="classB_1_1AutoUndo.html" title="Automatic management of undo action groups. ">AutoUndo</a>, which isolates application code from the undo policy. This is a good thing, because the precise configuration of undo policies (as discussed in <a class="el" href="using_undo.html#undo_policies">Undo Policies</a> above) is best considered to be an implementation detail.</p>
<p>Under the hood, <a class="el" href="classB_1_1AutoUndo.html" title="Automatic management of undo action groups. ">AutoUndo</a> communicates with policy objects via a set of custom Carbon Events. This allows <a class="el" href="classB_1_1AutoUndo.html" title="Automatic management of undo action groups. ">AutoUndo</a> to not have to worry about the location (Document? Application?) of the policy object.</p>
<p>If your application has special needs, it's possible to directly call member functions of policy objects. Both <a class="el" href="classB_1_1Application.html#aba83d2a43c5ae32c67f9ac9f2dd3823f" title="Returns the application&#39;s undo policy. ">Application::GetUndoPolicy()</a> and Document::GetUndoPolicy() provide access to those class' policy objects. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyClass::MyUndoableSetThingy(<span class="keywordtype">int</span> inNewThingy)</div><div class="line">{</div><div class="line">    MultipleUndoPolicy&amp; policy  = MyGetUndoPolicy();</div><div class="line">    </div><div class="line">    policy.BeginGroup(<a class="code" href="classB_1_1String.html">B::String</a>(<span class="stringliteral">&quot;Change Thingy&quot;</span>));</div><div class="line">    </div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        policy.Add(boost::bind(&amp;MyClass::MyUndoableSetThingy, <span class="keyword">this</span>, mThingy));</div><div class="line">        </div><div class="line">        mThingy = inNewThingy;</div><div class="line">        </div><div class="line">        policy.CommitGroup();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">        policy.AbortGroup();</div><div class="line">        </div><div class="line">        <span class="keywordflow">throw</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This implementation will be faster than the others because it doesn't bother with the overhead of creating and dispatching Carbon Events. It is however much more verbose, as well as tightly bound to the exact undo policy class chosen for either <a class="el" href="classB_1_1Document.html" title="A concrete Document class. ">Document</a> or <a class="el" href="classB_1_1Application.html" title="The application object. ">Application</a>, depending on how <code>MyGetUndoPolicy()</code> is implemented. This implementation is probably a poor choice for most situations. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
