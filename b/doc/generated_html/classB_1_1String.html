<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>B: B::String Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">B
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceB.html">B</a></li><li class="navelem"><a class="el" href="classB_1_1String.html">String</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classB_1_1String-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">B::String Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Adapter class for immutable strings.  
 <a href="classB_1_1String.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BString_8h_source.html">BString.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-modifiable iterator on a string.  <a href="classB_1_1String_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifiable iterator on a string.  <a href="classB_1_1String_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String_1_1reference.html">reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifiable reference to a character in a string.  <a href="classB_1_1String_1_1reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Types</div></td></tr>
<tr class="memitem:ad4301cd6e4f00f52bcc7e8ad14efffef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4301cd6e4f00f52bcc7e8ad14efffef"></a>
typedef UniChar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ad4301cd6e4f00f52bcc7e8ad14efffef">value_type</a></td></tr>
<tr class="memdesc:ad4301cd6e4f00f52bcc7e8ad14efffef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the characters. <br /></td></tr>
<tr class="separator:ad4301cd6e4f00f52bcc7e8ad14efffef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af754e00a7fd0be2c5fa859483e7e3bf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af754e00a7fd0be2c5fa859483e7e3bf5"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a></td></tr>
<tr class="memdesc:af754e00a7fd0be2c5fa859483e7e3bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unsigned integral type for size values and indices. <br /></td></tr>
<tr class="separator:af754e00a7fd0be2c5fa859483e7e3bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1e1eb61ea5e1e29c4201bea8d2fe39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b1e1eb61ea5e1e29c4201bea8d2fe39"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a4b1e1eb61ea5e1e29c4201bea8d2fe39">difference_type</a></td></tr>
<tr class="memdesc:a4b1e1eb61ea5e1e29c4201bea8d2fe39"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signed integral type for difference values. <br /></td></tr>
<tr class="separator:a4b1e1eb61ea5e1e29c4201bea8d2fe39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1486fc75f7538e8de3185a8afc69079"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1486fc75f7538e8de3185a8afc69079"></a>
typedef <a class="el" href="classB_1_1String.html#ad4301cd6e4f00f52bcc7e8ad14efffef">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ae1486fc75f7538e8de3185a8afc69079">const_reference</a></td></tr>
<tr class="memdesc:ae1486fc75f7538e8de3185a8afc69079"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of constant character references. <br /></td></tr>
<tr class="separator:ae1486fc75f7538e8de3185a8afc69079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c0b5c235760393977b6c0a1d17ccec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6c0b5c235760393977b6c0a1d17ccec"></a>
typedef <a class="el" href="classB_1_1String.html#ad4301cd6e4f00f52bcc7e8ad14efffef">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ad6c0b5c235760393977b6c0a1d17ccec">pointer</a></td></tr>
<tr class="memdesc:ad6c0b5c235760393977b6c0a1d17ccec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of constant character pointers. <br /></td></tr>
<tr class="separator:ad6c0b5c235760393977b6c0a1d17ccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc4036ee4490d74e20e3bb52da46d7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dc4036ee4490d74e20e3bb52da46d7f"></a>
typedef const <a class="el" href="classB_1_1String.html#ad4301cd6e4f00f52bcc7e8ad14efffef">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a1dc4036ee4490d74e20e3bb52da46d7f">const_pointer</a></td></tr>
<tr class="memdesc:a1dc4036ee4490d74e20e3bb52da46d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of constant character pointers. <br /></td></tr>
<tr class="separator:a1dc4036ee4490d74e20e3bb52da46d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1be22087c80790a9f1ca08cff5e5bc3"><td class="memItemLeft" align="right" valign="top">typedef CFAllocatorRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#af1be22087c80790a9f1ca08cff5e5bc3">allocator_type</a></td></tr>
<tr class="memdesc:af1be22087c80790a9f1ca08cff5e5bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of constant iterators.  <a href="#af1be22087c80790a9f1ca08cff5e5bc3">More...</a><br /></td></tr>
<tr class="separator:af1be22087c80790a9f1ca08cff5e5bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf93f33cad38860986a1c10d9226cf43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf93f33cad38860986a1c10d9226cf43"></a>
typedef std::reverse_iterator&lt; <a class="el" href="classB_1_1String_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#adf93f33cad38860986a1c10d9226cf43">reverse_iterator</a></td></tr>
<tr class="memdesc:adf93f33cad38860986a1c10d9226cf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of reverse iterators. <br /></td></tr>
<tr class="separator:adf93f33cad38860986a1c10d9226cf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a5b7e607c81ff3230521395bea610d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24a5b7e607c81ff3230521395bea610d"></a>
typedef std::reverse_iterator&lt; <a class="el" href="classB_1_1String_1_1const__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a24a5b7e607c81ff3230521395bea610d">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a24a5b7e607c81ff3230521395bea610d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of constant reverse iterators. <br /></td></tr>
<tr class="separator:a24a5b7e607c81ff3230521395bea610d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors / Destructor</div></td></tr>
<tr class="memitem:a77389a7e45c336c0e695486d9e23b6b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a77389a7e45c336c0e695486d9e23b6b9">String</a> ()</td></tr>
<tr class="memdesc:a77389a7e45c336c0e695486d9e23b6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a77389a7e45c336c0e695486d9e23b6b9">More...</a><br /></td></tr>
<tr class="separator:a77389a7e45c336c0e695486d9e23b6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84593e5ecf35ec2ab965a27716abdf04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a84593e5ecf35ec2ab965a27716abdf04">String</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a84593e5ecf35ec2ab965a27716abdf04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a84593e5ecf35ec2ab965a27716abdf04">More...</a><br /></td></tr>
<tr class="separator:a84593e5ecf35ec2ab965a27716abdf04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159e9ffc35cee9a8453872941ad28809"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a159e9ffc35cee9a8453872941ad28809">String</a> (CFAllocatorRef allocator)</td></tr>
<tr class="memdesc:a159e9ffc35cee9a8453872941ad28809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator constructor.  <a href="#a159e9ffc35cee9a8453872941ad28809">More...</a><br /></td></tr>
<tr class="separator:a159e9ffc35cee9a8453872941ad28809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc06b0c84ed7fb98e5aedb06bb6727c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a0bc06b0c84ed7fb98e5aedb06bb6727c">String</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;str, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:a0bc06b0c84ed7fb98e5aedb06bb6727c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> constructor.  <a href="#a0bc06b0c84ed7fb98e5aedb06bb6727c">More...</a><br /></td></tr>
<tr class="separator:a0bc06b0c84ed7fb98e5aedb06bb6727c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c5b56ace417e4375c03c20534c842f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a75c5b56ace417e4375c03c20534c842f">String</a> (const <a class="el" href="classB_1_1MutableString.html">MutableString</a> &amp;str)</td></tr>
<tr class="memdesc:a75c5b56ace417e4375c03c20534c842f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classB_1_1MutableString.html" title="Adapter class for changeable strings. ">MutableString</a> constructor.  <a href="#a75c5b56ace417e4375c03c20534c842f">More...</a><br /></td></tr>
<tr class="separator:a75c5b56ace417e4375c03c20534c842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f7e554621e1f90f1686303bdf7e69a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aa7f7e554621e1f90f1686303bdf7e69a">String</a> (const <a class="el" href="classB_1_1MutableString.html">MutableString</a> &amp;str, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:aa7f7e554621e1f90f1686303bdf7e69a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classB_1_1MutableString.html" title="Adapter class for changeable strings. ">MutableString</a> constructor.  <a href="#aa7f7e554621e1f90f1686303bdf7e69a">More...</a><br /></td></tr>
<tr class="separator:aa7f7e554621e1f90f1686303bdf7e69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcd0c581472e52e36f293e8f6a48f70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aafcd0c581472e52e36f293e8f6a48f70">String</a> (CFStringRef cfstr)</td></tr>
<tr class="memdesc:aafcd0c581472e52e36f293e8f6a48f70"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFStringRef</code> constructor.  <a href="#aafcd0c581472e52e36f293e8f6a48f70">More...</a><br /></td></tr>
<tr class="separator:aafcd0c581472e52e36f293e8f6a48f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14244ad0592bbafa31df9921d758db8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ab14244ad0592bbafa31df9921d758db8">String</a> (CFStringRef cfstr, const <a class="el" href="structB_1_1from__copy__t.html">from_copy_t</a> &amp;)</td></tr>
<tr class="memdesc:ab14244ad0592bbafa31df9921d758db8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFStringRef</code> constructor.  <a href="#ab14244ad0592bbafa31df9921d758db8">More...</a><br /></td></tr>
<tr class="separator:ab14244ad0592bbafa31df9921d758db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae263e0c254974363e02b53dcf096ae09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ae263e0c254974363e02b53dcf096ae09">String</a> (CFStringRef cfstr, const std::nothrow_t &amp;)</td></tr>
<tr class="memdesc:ae263e0c254974363e02b53dcf096ae09"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFStringRef</code> constructor.  <a href="#ae263e0c254974363e02b53dcf096ae09">More...</a><br /></td></tr>
<tr class="separator:ae263e0c254974363e02b53dcf096ae09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac231a92f06749b1afd6624db23b3a7d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ac231a92f06749b1afd6624db23b3a7d5">String</a> (CFStringRef cfstr, const <a class="el" href="structB_1_1from__copy__t.html">from_copy_t</a> &amp;, const std::nothrow_t &amp;)</td></tr>
<tr class="memdesc:ac231a92f06749b1afd6624db23b3a7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFStringRef</code> constructor.  <a href="#ac231a92f06749b1afd6624db23b3a7d5">More...</a><br /></td></tr>
<tr class="separator:ac231a92f06749b1afd6624db23b3a7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc6aaf495374a66e2287070744499c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#afdc6aaf495374a66e2287070744499c6">String</a> (CFStringRef cfstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:afdc6aaf495374a66e2287070744499c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFStringRef</code> constructor.  <a href="#afdc6aaf495374a66e2287070744499c6">More...</a><br /></td></tr>
<tr class="separator:afdc6aaf495374a66e2287070744499c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed6dc7f6eb9015f100b9b43aa1038f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a9ed6dc7f6eb9015f100b9b43aa1038f3">String</a> (const UniChar *ustr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:a9ed6dc7f6eb9015f100b9b43aa1038f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>UniChar</code> array constructor.  <a href="#a9ed6dc7f6eb9015f100b9b43aa1038f3">More...</a><br /></td></tr>
<tr class="separator:a9ed6dc7f6eb9015f100b9b43aa1038f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6873c4b0fd0cbb43b562b49efeb804cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a6873c4b0fd0cbb43b562b49efeb804cd">String</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n, UniChar c, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:a6873c4b0fd0cbb43b562b49efeb804cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>UniChar</code> constructor.  <a href="#a6873c4b0fd0cbb43b562b49efeb804cd">More...</a><br /></td></tr>
<tr class="separator:a6873c4b0fd0cbb43b562b49efeb804cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834590b2ba58aff33f8cb5bd989b84fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a834590b2ba58aff33f8cb5bd989b84fd">String</a> (const std::wstring &amp;wstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:a834590b2ba58aff33f8cb5bd989b84fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>std::wstring</code> constructor.  <a href="#a834590b2ba58aff33f8cb5bd989b84fd">More...</a><br /></td></tr>
<tr class="separator:a834590b2ba58aff33f8cb5bd989b84fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f7cad4fb6e93fa0b5ef9025e86fc43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a17f7cad4fb6e93fa0b5ef9025e86fc43">String</a> (const wchar_t *wcstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:a17f7cad4fb6e93fa0b5ef9025e86fc43"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>wchar_t</code> array constructor.  <a href="#a17f7cad4fb6e93fa0b5ef9025e86fc43">More...</a><br /></td></tr>
<tr class="separator:a17f7cad4fb6e93fa0b5ef9025e86fc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a059cf243258317190a6a955b6df22f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a6a059cf243258317190a6a955b6df22f">String</a> (const std::string &amp;sstr, CFStringEncoding encoding=kCFStringEncodingASCII, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:a6a059cf243258317190a6a955b6df22f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>std::string</code> constructor.  <a href="#a6a059cf243258317190a6a955b6df22f">More...</a><br /></td></tr>
<tr class="separator:a6a059cf243258317190a6a955b6df22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2795c89535e8e7f39ae22aebd9971374"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a2795c89535e8e7f39ae22aebd9971374">String</a> (const char *cstr, CFStringEncoding encoding=kCFStringEncodingASCII, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:a2795c89535e8e7f39ae22aebd9971374"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>char*</code> array constructor.  <a href="#a2795c89535e8e7f39ae22aebd9971374">More...</a><br /></td></tr>
<tr class="separator:a2795c89535e8e7f39ae22aebd9971374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefb2813fdebb8225c5eb6755eaee834"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#acefb2813fdebb8225c5eb6755eaee834">String</a> (ConstStringPtr pstr, CFStringEncoding encoding=kCFStringEncodingASCII, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:acefb2813fdebb8225c5eb6755eaee834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pascal string constructor.  <a href="#acefb2813fdebb8225c5eb6755eaee834">More...</a><br /></td></tr>
<tr class="separator:acefb2813fdebb8225c5eb6755eaee834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dda85fd2e7578a9b3700ce5f837605"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ac0dda85fd2e7578a9b3700ce5f837605">String</a> (const std::vector&lt; UInt8 &gt; &amp;blob, CFStringEncoding encoding, bool external, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:ac0dda85fd2e7578a9b3700ce5f837605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blob constructor.  <a href="#ac0dda85fd2e7578a9b3700ce5f837605">More...</a><br /></td></tr>
<tr class="separator:ac0dda85fd2e7578a9b3700ce5f837605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e11aa572fa7246b4723ab829b170aad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a2e11aa572fa7246b4723ab829b170aad">String</a> (const <a class="el" href="classB_1_1OSPtr.html">OSPtr</a>&lt; CFStringRef &gt; &amp;cfstr)</td></tr>
<tr class="memdesc:a2e11aa572fa7246b4723ab829b170aad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classB_1_1OSPtr.html">OSPtr&lt;CFStringRef&gt;</a></code> constructor.  <a href="#a2e11aa572fa7246b4723ab829b170aad">More...</a><br /></td></tr>
<tr class="separator:a2e11aa572fa7246b4723ab829b170aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83d48f4091b7f2dac05b45af7f31288"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ae83d48f4091b7f2dac05b45af7f31288">String</a> (const <a class="el" href="classB_1_1OSPtr.html">OSPtr</a>&lt; CFMutableStringRef &gt; &amp;cfstr)</td></tr>
<tr class="memdesc:ae83d48f4091b7f2dac05b45af7f31288"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>OSPtr&lt;CFMutableStringRef&gt;</code> constructor.  <a href="#ae83d48f4091b7f2dac05b45af7f31288">More...</a><br /></td></tr>
<tr class="separator:ae83d48f4091b7f2dac05b45af7f31288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b50d6e9c5d4915a0156f345badfbda9"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a2b50d6e9c5d4915a0156f345badfbda9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a2b50d6e9c5d4915a0156f345badfbda9">String</a> (InputIterator first, InputIterator last, CFAllocatorRef allocator=NULL)</td></tr>
<tr class="memdesc:a2b50d6e9c5d4915a0156f345badfbda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor.  <a href="#a2b50d6e9c5d4915a0156f345badfbda9">More...</a><br /></td></tr>
<tr class="separator:a2b50d6e9c5d4915a0156f345badfbda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7eafa4ef22718381aee641451d495e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e7eafa4ef22718381aee641451d495e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a0e7eafa4ef22718381aee641451d495e">~String</a> ()</td></tr>
<tr class="memdesc:a0e7eafa4ef22718381aee641451d495e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a0e7eafa4ef22718381aee641451d495e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations for Size and Capacity</div></td></tr>
<tr class="memitem:aa0b6379ad3d263696ab1bdfd07c120a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0b6379ad3d263696ab1bdfd07c120a1"></a>
<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aa0b6379ad3d263696ab1bdfd07c120a1">size</a> () const </td></tr>
<tr class="memdesc:aa0b6379ad3d263696ab1bdfd07c120a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters in the string. <br /></td></tr>
<tr class="separator:aa0b6379ad3d263696ab1bdfd07c120a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06622f8a89ce9cf3353563066607a49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac06622f8a89ce9cf3353563066607a49"></a>
<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ac06622f8a89ce9cf3353563066607a49">length</a> () const </td></tr>
<tr class="memdesc:ac06622f8a89ce9cf3353563066607a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters in the string. <br /></td></tr>
<tr class="separator:ac06622f8a89ce9cf3353563066607a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00076add9602b7a5f3708b1c9c5f0ecf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00076add9602b7a5f3708b1c9c5f0ecf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a00076add9602b7a5f3708b1c9c5f0ecf">empty</a> () const </td></tr>
<tr class="memdesc:a00076add9602b7a5f3708b1c9c5f0ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the string is empty. <br /></td></tr>
<tr class="separator:a00076add9602b7a5f3708b1c9c5f0ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ba68a59b60a22e9a065f1f27e66d77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5ba68a59b60a22e9a065f1f27e66d77"></a>
<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ab5ba68a59b60a22e9a065f1f27e66d77">max_size</a> () const </td></tr>
<tr class="memdesc:ab5ba68a59b60a22e9a065f1f27e66d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of characters a string could contain. <br /></td></tr>
<tr class="separator:ab5ba68a59b60a22e9a065f1f27e66d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12bb0195985a5efd2db7ce6d77167d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae12bb0195985a5efd2db7ce6d77167d1"></a>
<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ae12bb0195985a5efd2db7ce6d77167d1">capacity</a> () const </td></tr>
<tr class="memdesc:ae12bb0195985a5efd2db7ce6d77167d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters the string could contain without reallocation. <br /></td></tr>
<tr class="separator:ae12bb0195985a5efd2db7ce6d77167d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparisons</div></td></tr>
<tr class="memitem:a34345998d4dfc32c8e54683af6c45ef7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a34345998d4dfc32c8e54683af6c45ef7">compare</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;str) const </td></tr>
<tr class="memdesc:a34345998d4dfc32c8e54683af6c45ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>str</em>.  <a href="#a34345998d4dfc32c8e54683af6c45ef7">More...</a><br /></td></tr>
<tr class="separator:a34345998d4dfc32c8e54683af6c45ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b481ce9da0fbe3ade82edf1f918a0fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a7b481ce9da0fbe3ade82edf1f918a0fa">compare</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos1, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n1, const <a class="el" href="classB_1_1String.html">String</a> &amp;str) const </td></tr>
<tr class="memdesc:a7b481ce9da0fbe3ade82edf1f918a0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>str</em>.  <a href="#a7b481ce9da0fbe3ade82edf1f918a0fa">More...</a><br /></td></tr>
<tr class="separator:a7b481ce9da0fbe3ade82edf1f918a0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad488cebd5d1a4773c01ca081e779e70c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ad488cebd5d1a4773c01ca081e779e70c">compare</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos1, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n1, const <a class="el" href="classB_1_1String.html">String</a> &amp;str, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos2, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n2) const </td></tr>
<tr class="memdesc:ad488cebd5d1a4773c01ca081e779e70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>str</em>.  <a href="#ad488cebd5d1a4773c01ca081e779e70c">More...</a><br /></td></tr>
<tr class="separator:ad488cebd5d1a4773c01ca081e779e70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c057c992cfe329462d187682bf4e58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a46c057c992cfe329462d187682bf4e58">compare</a> (CFStringRef cfstr) const </td></tr>
<tr class="memdesc:a46c057c992cfe329462d187682bf4e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>cfstr</em>.  <a href="#a46c057c992cfe329462d187682bf4e58">More...</a><br /></td></tr>
<tr class="separator:a46c057c992cfe329462d187682bf4e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a55ec1252a7303e4cd777df4f22048a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a1a55ec1252a7303e4cd777df4f22048a">compare</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos1, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n1, CFStringRef cfstr) const </td></tr>
<tr class="memdesc:a1a55ec1252a7303e4cd777df4f22048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>cfstr</em>.  <a href="#a1a55ec1252a7303e4cd777df4f22048a">More...</a><br /></td></tr>
<tr class="separator:a1a55ec1252a7303e4cd777df4f22048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5c92f07ef9da317261e8f5d3f53038"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a1e5c92f07ef9da317261e8f5d3f53038">compare</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos1, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n1, CFStringRef cfstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos2, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n2) const </td></tr>
<tr class="memdesc:a1e5c92f07ef9da317261e8f5d3f53038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>cfstr</em>.  <a href="#a1e5c92f07ef9da317261e8f5d3f53038">More...</a><br /></td></tr>
<tr class="separator:a1e5c92f07ef9da317261e8f5d3f53038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582c097e41f7cd90f4aadd1f5c94595d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a582c097e41f7cd90f4aadd1f5c94595d">compare</a> (const UniChar *ustr) const </td></tr>
<tr class="memdesc:a582c097e41f7cd90f4aadd1f5c94595d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>ustr</em>.  <a href="#a582c097e41f7cd90f4aadd1f5c94595d">More...</a><br /></td></tr>
<tr class="separator:a582c097e41f7cd90f4aadd1f5c94595d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fa80a190844b9ea3ab994f9be1fd72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a47fa80a190844b9ea3ab994f9be1fd72">compare</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos1, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n1, const UniChar *ustr) const </td></tr>
<tr class="memdesc:a47fa80a190844b9ea3ab994f9be1fd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>ustr</em>.  <a href="#a47fa80a190844b9ea3ab994f9be1fd72">More...</a><br /></td></tr>
<tr class="separator:a47fa80a190844b9ea3ab994f9be1fd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae446ce390a88d200aec8d982fb05bdde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ae446ce390a88d200aec8d982fb05bdde">compare</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos1, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n1, const UniChar *ustr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n2) const </td></tr>
<tr class="memdesc:ae446ce390a88d200aec8d982fb05bdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>ustr</em>.  <a href="#ae446ce390a88d200aec8d982fb05bdde">More...</a><br /></td></tr>
<tr class="separator:ae446ce390a88d200aec8d982fb05bdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7ab9cecf4857db64b6d627fcc1d2d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aeb7ab9cecf4857db64b6d627fcc1d2d3">compare</a> (const std::string &amp;sstr, CFStringEncoding encoding) const </td></tr>
<tr class="memdesc:aeb7ab9cecf4857db64b6d627fcc1d2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>sstr</em>.  <a href="#aeb7ab9cecf4857db64b6d627fcc1d2d3">More...</a><br /></td></tr>
<tr class="separator:aeb7ab9cecf4857db64b6d627fcc1d2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab162083e902ab7c383157a11653a4243"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ab162083e902ab7c383157a11653a4243">compare</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos1, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n1, const std::string &amp;sstr, CFStringEncoding encoding) const </td></tr>
<tr class="memdesc:ab162083e902ab7c383157a11653a4243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>sstr</em>.  <a href="#ab162083e902ab7c383157a11653a4243">More...</a><br /></td></tr>
<tr class="separator:ab162083e902ab7c383157a11653a4243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa11fb45d16fbaa5a2e1f053cc51647"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#abfa11fb45d16fbaa5a2e1f053cc51647">compare</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos1, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n1, const std::string &amp;sstr, CFStringEncoding encoding, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos2, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n2) const </td></tr>
<tr class="memdesc:abfa11fb45d16fbaa5a2e1f053cc51647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the string to <em>sstr</em>.  <a href="#abfa11fb45d16fbaa5a2e1f053cc51647">More...</a><br /></td></tr>
<tr class="separator:abfa11fb45d16fbaa5a2e1f053cc51647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Character Access</div></td></tr>
<tr class="memitem:a0551d7da3a456c96705c73afc7e08074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#ae1486fc75f7538e8de3185a8afc69079">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a0551d7da3a456c96705c73afc7e08074">operator[]</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos) const </td></tr>
<tr class="memdesc:a0551d7da3a456c96705c73afc7e08074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character at index <em>pos</em>.  <a href="#a0551d7da3a456c96705c73afc7e08074">More...</a><br /></td></tr>
<tr class="separator:a0551d7da3a456c96705c73afc7e08074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3647d17f9624fdcd97b62b75a7f3afea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#ae1486fc75f7538e8de3185a8afc69079">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a3647d17f9624fdcd97b62b75a7f3afea">at</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos) const </td></tr>
<tr class="memdesc:a3647d17f9624fdcd97b62b75a7f3afea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character at index <em>pos</em>.  <a href="#a3647d17f9624fdcd97b62b75a7f3afea">More...</a><br /></td></tr>
<tr class="separator:a3647d17f9624fdcd97b62b75a7f3afea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generating CFStringRefs and Character Arrays.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Because of the fundamental differences in underlying storage between <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> and <code>std::basic_string&lt;&gt;</code>, it's impossible to provide direct counterparts to <em><code>std::basic_string&lt;&gt;c_str()</code></em> and <code>std::basic_string&lt;&gt;data()</code>. <code><a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0" title="Returns the underlying CFStringRef. ">cf_ref()</a></code> is analogous to <code>c_str()</code>.</p>
<p>The various overloads of <a class="el" href="classB_1_1String.html#ab98caf544bf7fbc647686a4ef5708b82" title="Copies the string to a UniChar array. ">copy()</a> allow conversions from <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> to a number of output types. </p>
</div></td></tr>
<tr class="memitem:a7bc1603f038cefd35c245a2f86ad46d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bc1603f038cefd35c245a2f86ad46d0"></a>
CFStringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref</a> () const </td></tr>
<tr class="memdesc:a7bc1603f038cefd35c245a2f86ad46d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying <code>CFStringRef</code>. <br /></td></tr>
<tr class="separator:a7bc1603f038cefd35c245a2f86ad46d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864a36fd5e35f8c151682830a718e814"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a864a36fd5e35f8c151682830a718e814"></a>
<a class="el" href="classB_1_1OSPtr.html">OSPtr</a>&lt; CFStringRef &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a864a36fd5e35f8c151682830a718e814">cf_ptr</a> () const </td></tr>
<tr class="memdesc:a864a36fd5e35f8c151682830a718e814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a "smart pointer" to the underlying <code>CFStringRef</code>. <br /></td></tr>
<tr class="separator:a864a36fd5e35f8c151682830a718e814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98caf544bf7fbc647686a4ef5708b82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ab98caf544bf7fbc647686a4ef5708b82">copy</a> (UniChar *ustr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:ab98caf544bf7fbc647686a4ef5708b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string to a <code>UniChar</code> array.  <a href="#ab98caf544bf7fbc647686a4ef5708b82">More...</a><br /></td></tr>
<tr class="separator:ab98caf544bf7fbc647686a4ef5708b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31549acb4702ea1138817da9c61b44b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a31549acb4702ea1138817da9c61b44b7">copy</a> (wchar_t *wcstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a31549acb4702ea1138817da9c61b44b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string to a <code>wchar_t</code> array.  <a href="#a31549acb4702ea1138817da9c61b44b7">More...</a><br /></td></tr>
<tr class="separator:a31549acb4702ea1138817da9c61b44b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160f7b31d6a1c1f1dec6b434f7af3b85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a160f7b31d6a1c1f1dec6b434f7af3b85">copy</a> (char *cstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> &amp;pos, CFStringEncoding encoding) const </td></tr>
<tr class="memdesc:a160f7b31d6a1c1f1dec6b434f7af3b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies at most <em>n</em> bytes, starting at index <em>pos</em> in <code>*this</code>, into the buffer pointed to by <em>cstr</em>.  <a href="#a160f7b31d6a1c1f1dec6b434f7af3b85">More...</a><br /></td></tr>
<tr class="separator:a160f7b31d6a1c1f1dec6b434f7af3b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38d311bad371e0b12616742e487016b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ab38d311bad371e0b12616742e487016b">copy</a> (CFMutableStringRef cfstr) const </td></tr>
<tr class="memdesc:ab38d311bad371e0b12616742e487016b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string to a <code>CFMutableStringRef</code>.  <a href="#ab38d311bad371e0b12616742e487016b">More...</a><br /></td></tr>
<tr class="separator:ab38d311bad371e0b12616742e487016b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f377238c6696659cc9e881a5dfca48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a1f377238c6696659cc9e881a5dfca48f">copy</a> (std::wstring &amp;wstr) const </td></tr>
<tr class="memdesc:a1f377238c6696659cc9e881a5dfca48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string to a <code>std::wstring</code>.  <a href="#a1f377238c6696659cc9e881a5dfca48f">More...</a><br /></td></tr>
<tr class="separator:a1f377238c6696659cc9e881a5dfca48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac452366a48af4b0fff83685176c8bcb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ac452366a48af4b0fff83685176c8bcb0">copy</a> (std::string &amp;sstr, CFStringEncoding encoding) const </td></tr>
<tr class="memdesc:ac452366a48af4b0fff83685176c8bcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string to a <code>std::string</code>.  <a href="#ac452366a48af4b0fff83685176c8bcb0">More...</a><br /></td></tr>
<tr class="separator:ac452366a48af4b0fff83685176c8bcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbb576944184ee2a0b4ced9c2122abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#affbb576944184ee2a0b4ced9c2122abb">copy</a> (StringPtr pstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n, CFStringEncoding encoding) const </td></tr>
<tr class="memdesc:affbb576944184ee2a0b4ced9c2122abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string to a Pascal <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>.  <a href="#affbb576944184ee2a0b4ced9c2122abb">More...</a><br /></td></tr>
<tr class="separator:affbb576944184ee2a0b4ced9c2122abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21b1fc4a586145a9800bac87ae4a2e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ad21b1fc4a586145a9800bac87ae4a2e9">copy</a> (std::vector&lt; UInt8 &gt; &amp;blob, CFStringEncoding encoding, bool external, char loss_byte=0) const </td></tr>
<tr class="memdesc:ad21b1fc4a586145a9800bac87ae4a2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string to a blob.  <a href="#ad21b1fc4a586145a9800bac87ae4a2e9">More...</a><br /></td></tr>
<tr class="separator:ad21b1fc4a586145a9800bac87ae4a2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These various overloads of <code>operator</code> = and <code><a class="el" href="classB_1_1String.html#a11338555c7c063655cba5148522e4737" title="String assignemnt. ">assign()</a></code> replace the string's underlying <code>CFStringRef</code>. </p>
</div></td></tr>
<tr class="memitem:a37c912d8e45d861add183e8e6e36f5c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a37c912d8e45d861add183e8e6e36f5c0">operator=</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a37c912d8e45d861add183e8e6e36f5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> assignemnt.  <a href="#a37c912d8e45d861add183e8e6e36f5c0">More...</a><br /></td></tr>
<tr class="separator:a37c912d8e45d861add183e8e6e36f5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ad20be17741a6e6a632b83ecb62a48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ae3ad20be17741a6e6a632b83ecb62a48">operator=</a> (const <a class="el" href="classB_1_1MutableString.html">MutableString</a> &amp;str)</td></tr>
<tr class="memdesc:ae3ad20be17741a6e6a632b83ecb62a48"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classB_1_1MutableString.html" title="Adapter class for changeable strings. ">MutableString</a> assignemnt.  <a href="#ae3ad20be17741a6e6a632b83ecb62a48">More...</a><br /></td></tr>
<tr class="separator:ae3ad20be17741a6e6a632b83ecb62a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aeadbde60d5e1974f7e12615e09101"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a83aeadbde60d5e1974f7e12615e09101">operator=</a> (CFStringRef cfstr)</td></tr>
<tr class="memdesc:a83aeadbde60d5e1974f7e12615e09101"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFStringRef</code> assignemnt.  <a href="#a83aeadbde60d5e1974f7e12615e09101">More...</a><br /></td></tr>
<tr class="separator:a83aeadbde60d5e1974f7e12615e09101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126c20cadb9f7f7aeb21f8c3297bb7f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a126c20cadb9f7f7aeb21f8c3297bb7f0"></a>
<a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a126c20cadb9f7f7aeb21f8c3297bb7f0">operator=</a> (CFMutableStringRef cfstr)</td></tr>
<tr class="memdesc:a126c20cadb9f7f7aeb21f8c3297bb7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFMutableStringRef</code> assignemnt. <br /></td></tr>
<tr class="separator:a126c20cadb9f7f7aeb21f8c3297bb7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fc6fd6f830be76bf68e9502071f2df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a71fc6fd6f830be76bf68e9502071f2df">operator=</a> (const <a class="el" href="classB_1_1OSPtr.html">OSPtr</a>&lt; CFStringRef &gt; &amp;cfstr)</td></tr>
<tr class="memdesc:a71fc6fd6f830be76bf68e9502071f2df"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classB_1_1OSPtr.html">OSPtr&lt;CFStringRef&gt;</a></code> assignemnt.  <a href="#a71fc6fd6f830be76bf68e9502071f2df">More...</a><br /></td></tr>
<tr class="separator:a71fc6fd6f830be76bf68e9502071f2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7418a7fae4aaca772a6f8240829d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aee7418a7fae4aaca772a6f8240829d57">operator=</a> (const <a class="el" href="classB_1_1OSPtr.html">OSPtr</a>&lt; CFMutableStringRef &gt; &amp;cfstr)</td></tr>
<tr class="memdesc:aee7418a7fae4aaca772a6f8240829d57"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>OSPtr&lt;CFMutableStringRef&gt;</code> assignemnt.  <a href="#aee7418a7fae4aaca772a6f8240829d57">More...</a><br /></td></tr>
<tr class="separator:aee7418a7fae4aaca772a6f8240829d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f87e889ea15eb0e7b67f61f79227fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ae2f87e889ea15eb0e7b67f61f79227fb">operator=</a> (const UniChar *ustr)</td></tr>
<tr class="memdesc:ae2f87e889ea15eb0e7b67f61f79227fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>UniChar</code> array assignemnt.  <a href="#ae2f87e889ea15eb0e7b67f61f79227fb">More...</a><br /></td></tr>
<tr class="separator:ae2f87e889ea15eb0e7b67f61f79227fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0477f50762fb2645341af4bb84d436e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a0477f50762fb2645341af4bb84d436e3">operator=</a> (UniChar c)</td></tr>
<tr class="memdesc:a0477f50762fb2645341af4bb84d436e3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>UniChar</code> assignemnt.  <a href="#a0477f50762fb2645341af4bb84d436e3">More...</a><br /></td></tr>
<tr class="separator:a0477f50762fb2645341af4bb84d436e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a3f3ca8976e43991770c7bf89b4fc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ad4a3f3ca8976e43991770c7bf89b4fc9">operator=</a> (const std::wstring &amp;wstr)</td></tr>
<tr class="memdesc:ad4a3f3ca8976e43991770c7bf89b4fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>std::wstring</code> assignemnt.  <a href="#ad4a3f3ca8976e43991770c7bf89b4fc9">More...</a><br /></td></tr>
<tr class="separator:ad4a3f3ca8976e43991770c7bf89b4fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3337b2d4349159ef6b005e48d95568ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a3337b2d4349159ef6b005e48d95568ea">operator=</a> (const wchar_t *ustr)</td></tr>
<tr class="memdesc:a3337b2d4349159ef6b005e48d95568ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-terminated <code>wchar_t</code> array assignemnt.  <a href="#a3337b2d4349159ef6b005e48d95568ea">More...</a><br /></td></tr>
<tr class="separator:a3337b2d4349159ef6b005e48d95568ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929206d4159eb85f9754f946b8272913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a929206d4159eb85f9754f946b8272913">operator=</a> (const std::string &amp;sstr)</td></tr>
<tr class="memdesc:a929206d4159eb85f9754f946b8272913"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>std::string</code> assignemnt.  <a href="#a929206d4159eb85f9754f946b8272913">More...</a><br /></td></tr>
<tr class="separator:a929206d4159eb85f9754f946b8272913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b35cd160ec1aa808ac9fa9ce19f3314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a8b35cd160ec1aa808ac9fa9ce19f3314">operator=</a> (const char *cstr)</td></tr>
<tr class="memdesc:a8b35cd160ec1aa808ac9fa9ce19f3314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-terminated <code>char</code> array assignemnt.  <a href="#a8b35cd160ec1aa808ac9fa9ce19f3314">More...</a><br /></td></tr>
<tr class="separator:a8b35cd160ec1aa808ac9fa9ce19f3314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f8db96d79fe465f0f150292af911e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aa0f8db96d79fe465f0f150292af911e0">operator=</a> (ConstStringPtr pstr)</td></tr>
<tr class="memdesc:aa0f8db96d79fe465f0f150292af911e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pascal string assignemnt.  <a href="#aa0f8db96d79fe465f0f150292af911e0">More...</a><br /></td></tr>
<tr class="separator:aa0f8db96d79fe465f0f150292af911e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11338555c7c063655cba5148522e4737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a11338555c7c063655cba5148522e4737">assign</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;str, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>)</td></tr>
<tr class="memdesc:a11338555c7c063655cba5148522e4737"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> assignemnt.  <a href="#a11338555c7c063655cba5148522e4737">More...</a><br /></td></tr>
<tr class="separator:a11338555c7c063655cba5148522e4737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e4772d24fd4026bb9b3ead68a6293a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a00e4772d24fd4026bb9b3ead68a6293a">assign</a> (const <a class="el" href="classB_1_1MutableString.html">MutableString</a> &amp;str, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>)</td></tr>
<tr class="memdesc:a00e4772d24fd4026bb9b3ead68a6293a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classB_1_1MutableString.html" title="Adapter class for changeable strings. ">MutableString</a> assignemnt.  <a href="#a00e4772d24fd4026bb9b3ead68a6293a">More...</a><br /></td></tr>
<tr class="separator:a00e4772d24fd4026bb9b3ead68a6293a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77390f7c529f826132073d9ac24a4c5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77390f7c529f826132073d9ac24a4c5c"></a>
<a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a77390f7c529f826132073d9ac24a4c5c">assign</a> (CFStringRef cfstr)</td></tr>
<tr class="memdesc:a77390f7c529f826132073d9ac24a4c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFStringRef</code> assignemnt. <br /></td></tr>
<tr class="separator:a77390f7c529f826132073d9ac24a4c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa70d880c9012fda01d9dfd30928410e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aaa70d880c9012fda01d9dfd30928410e">assign</a> (CFStringRef cfstr, const <a class="el" href="structB_1_1from__copy__t.html">from_copy_t</a> &amp;)</td></tr>
<tr class="memdesc:aaa70d880c9012fda01d9dfd30928410e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFStringRef</code> assignemnt.  <a href="#aaa70d880c9012fda01d9dfd30928410e">More...</a><br /></td></tr>
<tr class="separator:aaa70d880c9012fda01d9dfd30928410e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b5cfa71803034b3c2f17fdeb3ed9fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a36b5cfa71803034b3c2f17fdeb3ed9fe">assign</a> (CFStringRef cfstr, const std::nothrow_t &amp;)</td></tr>
<tr class="memdesc:a36b5cfa71803034b3c2f17fdeb3ed9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFStringRef</code> assignemnt.  <a href="#a36b5cfa71803034b3c2f17fdeb3ed9fe">More...</a><br /></td></tr>
<tr class="separator:a36b5cfa71803034b3c2f17fdeb3ed9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a1d498a4064264e6a6028c476fe099"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a45a1d498a4064264e6a6028c476fe099">assign</a> (CFStringRef cfstr, const <a class="el" href="structB_1_1from__copy__t.html">from_copy_t</a> &amp;, const std::nothrow_t &amp;)</td></tr>
<tr class="memdesc:a45a1d498a4064264e6a6028c476fe099"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFStringRef</code> assignemnt.  <a href="#a45a1d498a4064264e6a6028c476fe099">More...</a><br /></td></tr>
<tr class="separator:a45a1d498a4064264e6a6028c476fe099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebca38136b748f38d5e512ad0714663d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aebca38136b748f38d5e512ad0714663d">assign</a> (CFStringRef cfstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>)</td></tr>
<tr class="memdesc:aebca38136b748f38d5e512ad0714663d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>CFStringRef</code> assignemnt.  <a href="#aebca38136b748f38d5e512ad0714663d">More...</a><br /></td></tr>
<tr class="separator:aebca38136b748f38d5e512ad0714663d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f54d77a93398bbf9692c1c8c6f12cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a2f54d77a93398bbf9692c1c8c6f12cd3">assign</a> (const UniChar *ustr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>)</td></tr>
<tr class="memdesc:a2f54d77a93398bbf9692c1c8c6f12cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>UniChar</code> array assignemnt.  <a href="#a2f54d77a93398bbf9692c1c8c6f12cd3">More...</a><br /></td></tr>
<tr class="separator:a2f54d77a93398bbf9692c1c8c6f12cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68fea2cff2ce9d18cbf0f9cdbd38407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ad68fea2cff2ce9d18cbf0f9cdbd38407">assign</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n, UniChar c)</td></tr>
<tr class="memdesc:ad68fea2cff2ce9d18cbf0f9cdbd38407"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>UniChar</code> assignemnt.  <a href="#ad68fea2cff2ce9d18cbf0f9cdbd38407">More...</a><br /></td></tr>
<tr class="separator:ad68fea2cff2ce9d18cbf0f9cdbd38407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff509daa6e9a9eb22ec3b3b2b41ceed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#adff509daa6e9a9eb22ec3b3b2b41ceed">assign</a> (const std::wstring &amp;wstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>)</td></tr>
<tr class="memdesc:adff509daa6e9a9eb22ec3b3b2b41ceed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>std::wstring</code> assignemnt.  <a href="#adff509daa6e9a9eb22ec3b3b2b41ceed">More...</a><br /></td></tr>
<tr class="separator:adff509daa6e9a9eb22ec3b3b2b41ceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4599d5c6015420577df35f6697346e27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a4599d5c6015420577df35f6697346e27">assign</a> (const wchar_t *wcstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>)</td></tr>
<tr class="memdesc:a4599d5c6015420577df35f6697346e27"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>wchar_t</code> array assignemnt.  <a href="#a4599d5c6015420577df35f6697346e27">More...</a><br /></td></tr>
<tr class="separator:a4599d5c6015420577df35f6697346e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a2f55f3b227fdad4e12bd20cdb0c17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aa8a2f55f3b227fdad4e12bd20cdb0c17">assign</a> (const std::string &amp;sstr, CFStringEncoding encoding, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>)</td></tr>
<tr class="memdesc:aa8a2f55f3b227fdad4e12bd20cdb0c17"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>std::string</code> assignemnt.  <a href="#aa8a2f55f3b227fdad4e12bd20cdb0c17">More...</a><br /></td></tr>
<tr class="separator:aa8a2f55f3b227fdad4e12bd20cdb0c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc6bd6912a5dd5f2bd78e02566840ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a7cc6bd6912a5dd5f2bd78e02566840ce">assign</a> (const char *cstr, CFStringEncoding encoding, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>)</td></tr>
<tr class="memdesc:a7cc6bd6912a5dd5f2bd78e02566840ce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>char</code> array assignemnt.  <a href="#a7cc6bd6912a5dd5f2bd78e02566840ce">More...</a><br /></td></tr>
<tr class="separator:a7cc6bd6912a5dd5f2bd78e02566840ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55e0a26e7b6098dff787112b76523dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ac55e0a26e7b6098dff787112b76523dd">assign</a> (ConstStringPtr pstr, CFStringEncoding encoding)</td></tr>
<tr class="memdesc:ac55e0a26e7b6098dff787112b76523dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pascal string assignemnt.  <a href="#ac55e0a26e7b6098dff787112b76523dd">More...</a><br /></td></tr>
<tr class="separator:ac55e0a26e7b6098dff787112b76523dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae823dcf30a157afab9b4e22f93b49f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a5ae823dcf30a157afab9b4e22f93b49f">assign</a> (const std::vector&lt; UInt8 &gt; &amp;blob, CFStringEncoding encoding, bool external)</td></tr>
<tr class="memdesc:a5ae823dcf30a157afab9b4e22f93b49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blob assignemnt.  <a href="#a5ae823dcf30a157afab9b4e22f93b49f">More...</a><br /></td></tr>
<tr class="separator:a5ae823dcf30a157afab9b4e22f93b49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c0927ec57e1cb74346019cc9260f7b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a24c0927ec57e1cb74346019cc9260f7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a24c0927ec57e1cb74346019cc9260f7b">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a24c0927ec57e1cb74346019cc9260f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range assignment.  <a href="#a24c0927ec57e1cb74346019cc9260f7b">More...</a><br /></td></tr>
<tr class="separator:a24c0927ec57e1cb74346019cc9260f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad83f38a74d6918dc0bb3df5ef2e58c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ad83f38a74d6918dc0bb3df5ef2e58c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap</a> (<a class="el" href="classB_1_1String.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a3ad83f38a74d6918dc0bb3df5ef2e58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the string with <em>str</em>. <br /></td></tr>
<tr class="separator:a3ad83f38a74d6918dc0bb3df5ef2e58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Erasing Characters</div></td></tr>
<tr class="memitem:a469eb70065a2870e79b0ebdd4c53b9f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a469eb70065a2870e79b0ebdd4c53b9f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a469eb70065a2870e79b0ebdd4c53b9f8">clear</a> ()</td></tr>
<tr class="memdesc:a469eb70065a2870e79b0ebdd4c53b9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all characters. <br /></td></tr>
<tr class="separator:a469eb70065a2870e79b0ebdd4c53b9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Finding a Character</div></td></tr>
<tr class="memitem:acecd0740356538b01722f1cda338ed97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#acecd0740356538b01722f1cda338ed97">find</a> (UniChar c, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:acecd0740356538b01722f1cda338ed97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of given character.  <a href="#acecd0740356538b01722f1cda338ed97">More...</a><br /></td></tr>
<tr class="separator:acecd0740356538b01722f1cda338ed97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293044d03e79db8a516b2c27d43acbd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a293044d03e79db8a516b2c27d43acbd8">rfind</a> (UniChar c, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a293044d03e79db8a516b2c27d43acbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of given character.  <a href="#a293044d03e79db8a516b2c27d43acbd8">More...</a><br /></td></tr>
<tr class="separator:a293044d03e79db8a516b2c27d43acbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Finding a Substring</div></td></tr>
<tr class="memitem:ab5ccc5704fa699f88a21261b78211b47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ab5ccc5704fa699f88a21261b78211b47">find</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;str, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:ab5ccc5704fa699f88a21261b78211b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>.  <a href="#ab5ccc5704fa699f88a21261b78211b47">More...</a><br /></td></tr>
<tr class="separator:ab5ccc5704fa699f88a21261b78211b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5c20d3f490cfe34f7103e443ae7f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#adf5c20d3f490cfe34f7103e443ae7f1e">rfind</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;str, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:adf5c20d3f490cfe34f7103e443ae7f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>.  <a href="#adf5c20d3f490cfe34f7103e443ae7f1e">More...</a><br /></td></tr>
<tr class="separator:adf5c20d3f490cfe34f7103e443ae7f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6474660b9cc22ddcae69a16a462cb49b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a6474660b9cc22ddcae69a16a462cb49b">find</a> (CFStringRef cfstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a6474660b9cc22ddcae69a16a462cb49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first <code>CFStringRef</code>.  <a href="#a6474660b9cc22ddcae69a16a462cb49b">More...</a><br /></td></tr>
<tr class="separator:a6474660b9cc22ddcae69a16a462cb49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9435942c1e4563c2bfaaf985335b5fd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a9435942c1e4563c2bfaaf985335b5fd0">rfind</a> (CFStringRef cfstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a9435942c1e4563c2bfaaf985335b5fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last <code>CFStringRef</code>.  <a href="#a9435942c1e4563c2bfaaf985335b5fd0">More...</a><br /></td></tr>
<tr class="separator:a9435942c1e4563c2bfaaf985335b5fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6d024f0988fb497b92ad75f2210808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a6d6d024f0988fb497b92ad75f2210808">find</a> (const UniChar *ustr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>) const </td></tr>
<tr class="memdesc:a6d6d024f0988fb497b92ad75f2210808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first <code>UniChar</code> array.  <a href="#a6d6d024f0988fb497b92ad75f2210808">More...</a><br /></td></tr>
<tr class="separator:a6d6d024f0988fb497b92ad75f2210808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b7ec55290bc266241518c529cb9af2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ae7b7ec55290bc266241518c529cb9af2">rfind</a> (const UniChar *ustr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>) const </td></tr>
<tr class="memdesc:ae7b7ec55290bc266241518c529cb9af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last <code>UniChar</code> array.  <a href="#ae7b7ec55290bc266241518c529cb9af2">More...</a><br /></td></tr>
<tr class="separator:ae7b7ec55290bc266241518c529cb9af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9ff47b9414c208bcf56f26809e554e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a7f9ff47b9414c208bcf56f26809e554e">find</a> (const std::string &amp;sstr, CFStringEncoding encoding, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a7f9ff47b9414c208bcf56f26809e554e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first <code>std::string</code>.  <a href="#a7f9ff47b9414c208bcf56f26809e554e">More...</a><br /></td></tr>
<tr class="separator:a7f9ff47b9414c208bcf56f26809e554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad625cb77a3ff27ea7a04c2f174df3a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ad625cb77a3ff27ea7a04c2f174df3a00">rfind</a> (const std::string &amp;sstr, CFStringEncoding encoding, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:ad625cb77a3ff27ea7a04c2f174df3a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last <code>std::string</code>.  <a href="#ad625cb77a3ff27ea7a04c2f174df3a00">More...</a><br /></td></tr>
<tr class="separator:ad625cb77a3ff27ea7a04c2f174df3a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Finding the First of a Set of Characters</div></td></tr>
<tr class="memitem:aeb90141bdfc3759290317c9284cb2050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aeb90141bdfc3759290317c9284cb2050">find_first_of</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;str, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:aeb90141bdfc3759290317c9284cb2050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in a set given as a <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>.  <a href="#aeb90141bdfc3759290317c9284cb2050">More...</a><br /></td></tr>
<tr class="separator:aeb90141bdfc3759290317c9284cb2050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf37f8aa9d688c26c21e69a01cd756c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aaaf37f8aa9d688c26c21e69a01cd756c">find_first_not_of</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;str, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:aaaf37f8aa9d688c26c21e69a01cd756c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character not in a set given as a <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>.  <a href="#aaaf37f8aa9d688c26c21e69a01cd756c">More...</a><br /></td></tr>
<tr class="separator:aaaf37f8aa9d688c26c21e69a01cd756c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d29fd0165f6f0937301136c705128c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a2d29fd0165f6f0937301136c705128c3">find_first_of</a> (CFStringRef cfstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a2d29fd0165f6f0937301136c705128c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in a set given as a <code>CFStringRef</code>.  <a href="#a2d29fd0165f6f0937301136c705128c3">More...</a><br /></td></tr>
<tr class="separator:a2d29fd0165f6f0937301136c705128c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1ecc5209d1954cee849ba0544138fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a6a1ecc5209d1954cee849ba0544138fe">find_first_not_of</a> (CFStringRef cfstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a6a1ecc5209d1954cee849ba0544138fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character not in a set given as a <code>CFStringRef</code>.  <a href="#a6a1ecc5209d1954cee849ba0544138fe">More...</a><br /></td></tr>
<tr class="separator:a6a1ecc5209d1954cee849ba0544138fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cffd38c1da37fd7d8468eb873b720d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ae4cffd38c1da37fd7d8468eb873b720d">find_first_of</a> (const UniChar *ustr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>) const </td></tr>
<tr class="memdesc:ae4cffd38c1da37fd7d8468eb873b720d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in a set given as a <code>UniChar</code> array.  <a href="#ae4cffd38c1da37fd7d8468eb873b720d">More...</a><br /></td></tr>
<tr class="separator:ae4cffd38c1da37fd7d8468eb873b720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1540504694c22537145a1a768fdc0b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a1540504694c22537145a1a768fdc0b22">find_first_not_of</a> (const UniChar *ustr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>) const </td></tr>
<tr class="memdesc:a1540504694c22537145a1a768fdc0b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character not in a set given as a <code>UniChar</code> array.  <a href="#a1540504694c22537145a1a768fdc0b22">More...</a><br /></td></tr>
<tr class="separator:a1540504694c22537145a1a768fdc0b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff1e369c4263c51e7a06d3faa659ff4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a3ff1e369c4263c51e7a06d3faa659ff4">find_first_of</a> (const std::string &amp;sstr, CFStringEncoding encoding, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a3ff1e369c4263c51e7a06d3faa659ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in a set given as a <code>std::string</code>.  <a href="#a3ff1e369c4263c51e7a06d3faa659ff4">More...</a><br /></td></tr>
<tr class="separator:a3ff1e369c4263c51e7a06d3faa659ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6086e541c67606533524f03e8b3101c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a6086e541c67606533524f03e8b3101c6">find_first_not_of</a> (const std::string &amp;sstr, CFStringEncoding encoding, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a6086e541c67606533524f03e8b3101c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character not in a set given as a <code>std::string</code>.  <a href="#a6086e541c67606533524f03e8b3101c6">More...</a><br /></td></tr>
<tr class="separator:a6086e541c67606533524f03e8b3101c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Finding the Last of a Set of Characters</div></td></tr>
<tr class="memitem:ac074820eb53b4785d27cba6e56d8811f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ac074820eb53b4785d27cba6e56d8811f">find_last_of</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;str, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:ac074820eb53b4785d27cba6e56d8811f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character in a set given as a <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>.  <a href="#ac074820eb53b4785d27cba6e56d8811f">More...</a><br /></td></tr>
<tr class="separator:ac074820eb53b4785d27cba6e56d8811f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063c81c7ff305f59ad2747dbefee1077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a063c81c7ff305f59ad2747dbefee1077">find_last_not_of</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;str, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a063c81c7ff305f59ad2747dbefee1077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character not in a set given as a <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>.  <a href="#a063c81c7ff305f59ad2747dbefee1077">More...</a><br /></td></tr>
<tr class="separator:a063c81c7ff305f59ad2747dbefee1077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b49e22e6da2a6e2c9a084d6911e796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a36b49e22e6da2a6e2c9a084d6911e796">find_last_of</a> (CFStringRef cfstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a36b49e22e6da2a6e2c9a084d6911e796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character in a set given as a <code>CFStringRef</code>.  <a href="#a36b49e22e6da2a6e2c9a084d6911e796">More...</a><br /></td></tr>
<tr class="separator:a36b49e22e6da2a6e2c9a084d6911e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7229f34827b9b0f956d55a87c7c33335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a7229f34827b9b0f956d55a87c7c33335">find_last_not_of</a> (CFStringRef cfstr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:a7229f34827b9b0f956d55a87c7c33335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character not in a set given as a <code>CFStringRef</code>.  <a href="#a7229f34827b9b0f956d55a87c7c33335">More...</a><br /></td></tr>
<tr class="separator:a7229f34827b9b0f956d55a87c7c33335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5335835b08d4cda293016e2cf55dc3ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a5335835b08d4cda293016e2cf55dc3ce">find_last_of</a> (const UniChar *ustr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>) const </td></tr>
<tr class="memdesc:a5335835b08d4cda293016e2cf55dc3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character in a set given as a <code>UniChar</code> array.  <a href="#a5335835b08d4cda293016e2cf55dc3ce">More...</a><br /></td></tr>
<tr class="separator:a5335835b08d4cda293016e2cf55dc3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab242d0dac28bc427ed928be948d014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a7ab242d0dac28bc427ed928be948d014">find_last_not_of</a> (const UniChar *ustr, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>) const </td></tr>
<tr class="memdesc:a7ab242d0dac28bc427ed928be948d014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character not in a set given as a <code>UniChar</code> array.  <a href="#a7ab242d0dac28bc427ed928be948d014">More...</a><br /></td></tr>
<tr class="separator:a7ab242d0dac28bc427ed928be948d014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c7575c6e99d9b6759ae30a0f735ad2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#af0c7575c6e99d9b6759ae30a0f735ad2">find_last_of</a> (const std::string &amp;sstr, CFStringEncoding encoding, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:af0c7575c6e99d9b6759ae30a0f735ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character in a set given as a <code>std::string</code>.  <a href="#af0c7575c6e99d9b6759ae30a0f735ad2">More...</a><br /></td></tr>
<tr class="separator:af0c7575c6e99d9b6759ae30a0f735ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa53c727945f5a2b07f5ca11b940027f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aaa53c727945f5a2b07f5ca11b940027f">find_last_not_of</a> (const std::string &amp;sstr, CFStringEncoding encoding, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0) const </td></tr>
<tr class="memdesc:aaa53c727945f5a2b07f5ca11b940027f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last character not in a set given as a <code>std::string</code>.  <a href="#aaa53c727945f5a2b07f5ca11b940027f">More...</a><br /></td></tr>
<tr class="separator:aaa53c727945f5a2b07f5ca11b940027f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Substrings</div></td></tr>
<tr class="memitem:a1d8e1a930d0f6c05253b1447ad389609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a1d8e1a930d0f6c05253b1447ad389609">substr</a> (<a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> pos=0, <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> n=<a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>) const </td></tr>
<tr class="memdesc:a1d8e1a930d0f6c05253b1447ad389609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring.  <a href="#a1d8e1a930d0f6c05253b1447ad389609">More...</a><br /></td></tr>
<tr class="separator:a1d8e1a930d0f6c05253b1447ad389609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generating Iterators</div></td></tr>
<tr class="memitem:a5ea578f54d8167869bd2c9c3f10c71e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ea578f54d8167869bd2c9c3f10c71e4"></a>
<a class="el" href="classB_1_1String_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a5ea578f54d8167869bd2c9c3f10c71e4">begin</a> () const </td></tr>
<tr class="memdesc:a5ea578f54d8167869bd2c9c3f10c71e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant random access iterator for the beginning of the string. <br /></td></tr>
<tr class="separator:a5ea578f54d8167869bd2c9c3f10c71e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4aa9439d5b3d167a941e2aabd81407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a4aa9439d5b3d167a941e2aabd81407"></a>
<a class="el" href="classB_1_1String_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a8a4aa9439d5b3d167a941e2aabd81407">end</a> () const </td></tr>
<tr class="memdesc:a8a4aa9439d5b3d167a941e2aabd81407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant random access iterator for the end of the string. <br /></td></tr>
<tr class="separator:a8a4aa9439d5b3d167a941e2aabd81407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c7cb2a76d7b6dfd781c3d6720f66c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28c7cb2a76d7b6dfd781c3d6720f66c7"></a>
<a class="el" href="classB_1_1String.html#a24a5b7e607c81ff3230521395bea610d">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a28c7cb2a76d7b6dfd781c3d6720f66c7">rbegin</a> () const </td></tr>
<tr class="memdesc:a28c7cb2a76d7b6dfd781c3d6720f66c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant random access iterator for the beginning of a reverse iteration of the string. <br /></td></tr>
<tr class="separator:a28c7cb2a76d7b6dfd781c3d6720f66c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6048002685cf4eca47a1d1defee76c56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6048002685cf4eca47a1d1defee76c56"></a>
<a class="el" href="classB_1_1String.html#a24a5b7e607c81ff3230521395bea610d">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a6048002685cf4eca47a1d1defee76c56">rend</a> () const </td></tr>
<tr class="memdesc:a6048002685cf4eca47a1d1defee76c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant random access iterator for the end of a reverse iteration of the string. <br /></td></tr>
<tr class="separator:a6048002685cf4eca47a1d1defee76c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Allocator Support</div></td></tr>
<tr class="memitem:a6f56a416adcc537505e0c0162b13c202"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f56a416adcc537505e0c0162b13c202"></a>
<a class="el" href="classB_1_1String.html#af1be22087c80790a9f1ca08cff5e5bc3">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator</a> () const </td></tr>
<tr class="memdesc:a6f56a416adcc537505e0c0162b13c202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string's allocator. <br /></td></tr>
<tr class="separator:a6f56a416adcc537505e0c0162b13c202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O Support</div></td></tr>
<tr class="memitem:a205639c5a363a748eac55bbd4e95bc6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a205639c5a363a748eac55bbd4e95bc6f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#a205639c5a363a748eac55bbd4e95bc6f">Write</a> (std::ostream &amp;ostr, CFStringEncoding encoding) const </td></tr>
<tr class="memdesc:a205639c5a363a748eac55bbd4e95bc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the characters of <em>str</em> to <em>ostr</em>. <br /></td></tr>
<tr class="separator:a205639c5a363a748eac55bbd4e95bc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac947eb2bf39f17959d26f11c1305a83d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac947eb2bf39f17959d26f11c1305a83d"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#ac947eb2bf39f17959d26f11c1305a83d">Read</a> (std::istream &amp;istr, CFStringEncoding encoding)</td></tr>
<tr class="memdesc:ac947eb2bf39f17959d26f11c1305a83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the characters of the next word from <em>istr</em> into the string. <br /></td></tr>
<tr class="separator:ac947eb2bf39f17959d26f11c1305a83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa409bbb99a71ba57303c239a3ffdb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaa409bbb99a71ba57303c239a3ffdb2"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aeaa409bbb99a71ba57303c239a3ffdb2">GetLine</a> (std::istream &amp;istr, char delim, CFStringEncoding encoding)</td></tr>
<tr class="memdesc:aeaa409bbb99a71ba57303c239a3ffdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the characters of the next line from <em>istr</em> into the string. <br /></td></tr>
<tr class="separator:aeaa409bbb99a71ba57303c239a3ffdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constants</div></td></tr>
<tr class="memitem:aeee24f0854e3bc2515fb2fa0b6e4ef44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeee24f0854e3bc2515fb2fa0b6e4ef44"></a>
static const <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a> = <a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>(-1)</td></tr>
<tr class="memdesc:aeee24f0854e3bc2515fb2fa0b6e4ef44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sentinel value meaning "not found" or "all remaining characters". <br /></td></tr>
<tr class="separator:aeee24f0854e3bc2515fb2fa0b6e4ef44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a42b7b91909b855bd39dc77a5fd64bd1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42b7b91909b855bd39dc77a5fd64bd1a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MutableString</b></td></tr>
<tr class="separator:a42b7b91909b855bd39dc77a5fd64bd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Concatenation</div></td></tr>
<tr class="memitem:gaa32f7361ca2291f8996eec46dd3baaed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classB_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MutableStringFunctions.html#gaa32f7361ca2291f8996eec46dd3baaed">operator+</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;s1, const <a class="el" href="classB_1_1String.html">String</a> &amp;s2)</td></tr>
<tr class="separator:gaa32f7361ca2291f8996eec46dd3baaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input/Output Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> only supports I/O to <code>char</code> streams (i.e., <code>std::basic_ostream&lt;char,char_traits&lt;char&gt;&gt;</code>). </p>
</div></td></tr>
<tr class="memitem:gac70449bc0760570cc77558615fef1fae"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gac70449bc0760570cc77558615fef1fae">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classB_1_1String.html">String</a> &amp;str)</td></tr>
<tr class="separator:gac70449bc0760570cc77558615fef1fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5eb8a0420d00e19a0e561a5c7d7ed16"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gad5eb8a0420d00e19a0e561a5c7d7ed16">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classB_1_1String.html">String</a> &amp;str)</td></tr>
<tr class="separator:gad5eb8a0420d00e19a0e561a5c7d7ed16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f6cfb8664505af0eec9db184be2d6e"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gad5f6cfb8664505af0eec9db184be2d6e">getline</a> (std::istream &amp;is, <a class="el" href="classB_1_1String.html">String</a> &amp;str, char delim)</td></tr>
<tr class="separator:gad5f6cfb8664505af0eec9db184be2d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc5e39b3dafb324eef5f6d07b80f281"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga1cc5e39b3dafb324eef5f6d07b80f281">getline</a> (std::istream &amp;is, <a class="el" href="classB_1_1String.html">String</a> &amp;str)</td></tr>
<tr class="separator:ga1cc5e39b3dafb324eef5f6d07b80f281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Comparisons</div></td></tr>
<tr class="memitem:gac7ed528200f695ceac3fde183f610cbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MutableStringFunctions.html#gac7ed528200f695ceac3fde183f610cbf">operator==</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;s1, const <a class="el" href="classB_1_1String.html">String</a> &amp;s2)</td></tr>
<tr class="separator:gac7ed528200f695ceac3fde183f610cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97ff88d821549d6f4334ad69ebdc08a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MutableStringFunctions.html#ga97ff88d821549d6f4334ad69ebdc08a0">operator!=</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;s1, const <a class="el" href="classB_1_1String.html">String</a> &amp;s2)</td></tr>
<tr class="separator:ga97ff88d821549d6f4334ad69ebdc08a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44236736216a76ffa77c5a7206c2511"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MutableStringFunctions.html#gae44236736216a76ffa77c5a7206c2511">operator&lt;</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;s1, const <a class="el" href="classB_1_1String.html">String</a> &amp;s2)</td></tr>
<tr class="separator:gae44236736216a76ffa77c5a7206c2511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34917218d8905a636d6b6b401c965757"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MutableStringFunctions.html#ga34917218d8905a636d6b6b401c965757">operator&lt;=</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;s1, const <a class="el" href="classB_1_1String.html">String</a> &amp;s2)</td></tr>
<tr class="separator:ga34917218d8905a636d6b6b401c965757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49c28125937cf2ab516cf2340b89f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MutableStringFunctions.html#gae49c28125937cf2ab516cf2340b89f1d">operator&gt;</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;s1, const <a class="el" href="classB_1_1String.html">String</a> &amp;s2)</td></tr>
<tr class="separator:gae49c28125937cf2ab516cf2340b89f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga340adc39198284be157ac07980eb5791"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MutableStringFunctions.html#ga340adc39198284be157ac07980eb5791">operator&gt;=</a> (const <a class="el" href="classB_1_1String.html">String</a> &amp;s1, const <a class="el" href="classB_1_1String.html">String</a> &amp;s2)</td></tr>
<tr class="separator:ga340adc39198284be157ac07980eb5791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous</div></td></tr>
<tr class="memitem:gac8dd2140170c99171f19218d6b60c97f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gac8dd2140170c99171f19218d6b60c97f">swap</a> (<a class="el" href="classB_1_1String.html">String</a> &amp;s1, <a class="el" href="classB_1_1String.html">String</a> &amp;s2)</td></tr>
<tr class="separator:gac8dd2140170c99171f19218d6b60c97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Adapter class for immutable strings. </p>
<p><a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> provides a wrapper around a CoreFoundation <code>CFStringRef</code> object, giving it an interface similar (nearly identical in fact) to <code>std::string</code>. This makes it possible to use <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> with STL algorithms, with standard streams, etc.</p>
<p><a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> tries to share its underlying <code>CFStringRef</code> whenever possible.</p>
<p>Specifically, <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> implements the <code>const</code> member functions of <code>std::string</code>. This reflects the immutable nature of the underlying <code>CFStringRef</code>. The exception to this is the various overloads of operator = () and <a class="el" href="classB_1_1String.html#a11338555c7c063655cba5148522e4737" title="String assignemnt. ">assign()</a>, whose absence would have made the class much more difficult to use; they are implemented by replacing the underlying <code>CFStringRef</code>, rather than by changing its contents.</p>
<p>Other notable differences with <code>std::basic_string&lt;...&gt;</code>: </p><pre class="fragment">- There are no template parameters, because CFStrings only have one underlying 
  character type, namely @c UniChar.  One can think of String as 
  analogous to &lt;tt&gt;std::basic_string&lt;UniChar,char_traits&lt;UniChar&gt;,CFAllocatorRef&gt;&lt;/tt&gt;.

- There are many more conversions.  This reflects String's role as an adapter 
  between CoreFoundation and the Standard C++ Library.  For example, one may 
  construct instances of String with any of the following types:
    - String
    - MutableString
    - &lt;tt&gt;CFStringRef&lt;/tt&gt;
    - &lt;tt&gt;const UniChar*&lt;/tt&gt;
    - &lt;tt&gt;std::string&lt;/tt&gt;
    - &lt;tt&gt;std::wstring&lt;/tt&gt;
    - &lt;tt&gt;const char*&lt;/tt&gt;
    - &lt;tt&gt;const wchar_t*&lt;/tt&gt;
    - &lt;tt&gt;UniChar&lt;/tt&gt;
    - &lt;tt&gt;ConstStringPtr&lt;/tt&gt;
    - &lt;tt&gt;std::vector&lt;UInt8&gt;&lt;/tt&gt;

- Likewise, one may copy() a String into one of the following data structures:
    - &lt;tt&gt;CFMutableStringRef&lt;/tt&gt;
    - &lt;tt&gt;std::string&lt;/tt&gt;
    - &lt;tt&gt;std::wstring&lt;/tt&gt;
    - &lt;tt&gt;char*&lt;/tt&gt;
    - &lt;tt&gt;wchar_t*&lt;/tt&gt;
    - &lt;tt&gt;UniChar*&lt;/tt&gt;
    - &lt;tt&gt;StringPtr&lt;/tt&gt;
    - &lt;tt&gt;std::vector&lt;UInt8&gt;&lt;/tt&gt;

- The allocator type is fixed as @c CFAllocatorRef.  The allocator type is not a 
  template parameter, however allocators @e are passed as arguments to 
  constructors and can be retrieved via get_allocator().

- The underlying @c CFStringRef's storage is not accessible, so it's not 
  possible to take the address of an element of a String.  String 
  is incompatible with the STL in this respect.
</pre><p>A number of related <code>#defines</code> provide support for localised strings, and are designed to integrate with Apple's localisation tools such as <code>genstrings</code>. They are: </p><pre class="fragment">- #BLocalizedString
- #BLocalizedStringFromTable
- #BLocalizedStringFromTableInBundle
- #BLocalizedStringWithDefaultValue</pre> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af1be22087c80790a9f1ca08cff5e5bc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef CFAllocatorRef <a class="el" href="classB_1_1String.html#af1be22087c80790a9f1ca08cff5e5bc3">B::String::allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of constant iterators. </p>
<p>The type of the allocator. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a77389a7e45c336c0e695486d9e23b6b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty string using the default allocator. </p>

<p>Referenced by <a class="el" href="group__MutableStringFunctions.html#gaf9a10094a2c538ff698cd931e70277a3">B::operator+()</a>, <a class="el" href="group__MutableStringFunctions.html#gaa32f7361ca2291f8996eec46dd3baaed">operator+()</a>, and <a class="el" href="classB_1_1String.html#a1d8e1a930d0f6c05253b1447ad389609">substr()</a>.</p>

</div>
</div>
<a class="anchor" id="a84593e5ecf35ec2ab965a27716abdf04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Creates a string as a copy of <em>str</em>, using <em>str's</em> allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The source string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a159e9ffc35cee9a8453872941ad28809"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bc06b0c84ed7fb98e5aedb06bb6727c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> constructor. </p>
<p>Creates a string that is initialised by, at most, the first <em>n</em> characters of <em>str</em> starting with index <em>pos</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The source string. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the copy within the source string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75c5b56ace417e4375c03c20534c842f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1MutableString.html">MutableString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classB_1_1MutableString.html" title="Adapter class for changeable strings. ">MutableString</a> constructor. </p>
<p>Creates a string as a copy of <em>str</em>, using <em>str's</em> allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The source string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1MutableString.html#a1acf8cfc358c1fd8f1f2035f204c51a1">B::MutableString::cf_ref()</a>, and <a class="el" href="classB_1_1MutableString.html#ab1c4bde9d291a29e5089dbffb79db74e">B::MutableString::get_allocator()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7f7e554621e1f90f1686303bdf7e69a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1MutableString.html">MutableString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classB_1_1MutableString.html" title="Adapter class for changeable strings. ">MutableString</a> constructor. </p>
<p>Creates a string that is initialised by, at most, the first <em>n</em> characters of <em>str</em> starting with index <em>pos</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The source string. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the copy within the source string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafcd0c581472e52e36f293e8f6a48f70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>CFStringRef</code> constructor. </p>
<p>Creates a string as a copy of <em>cfstr</em>, using <em>cfstr's</em> allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The source string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab14244ad0592bbafa31df9921d758db8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structB_1_1from__copy__t.html">from_copy_t</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>CFStringRef</code> constructor. </p>
<p>Creates a string as a copy of <em>cfstr</em>, using <em>cfstr's</em> allocator. The input string's retain count is not incremented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The source string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae263e0c254974363e02b53dcf096ae09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nothrow_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>CFStringRef</code> constructor. </p>
<p>Creates a string as a copy of <em>cfstr</em>, using <em>cfstr's</em> allocator. If <em>cfstr</em> is <code>NULL</code>, use an empty string instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The source string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac231a92f06749b1afd6624db23b3a7d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structB_1_1from__copy__t.html">from_copy_t</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nothrow_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>CFStringRef</code> constructor. </p>
<p>Creates a string as a copy of <em>cfstr</em>, using <em>cfstr's</em> allocator. If <em>cfstr</em> is <code>NULL</code>, use an empty string instead. The input string's retain count is not incremented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The source string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afdc6aaf495374a66e2287070744499c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>CFStringRef</code> constructor. </p>
<p>Creates a new string that is initialised by, at most, the first <em>n</em> characters of <em>cfstr</em> starting with index <em>pos</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The source string. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the copy within the source string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ed6dc7f6eb9015f100b9b43aa1038f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>UniChar</code> array constructor. </p>
<p>Creates a string that is initialised by, at most, the first <em>n</em> characters of <em>ustr</em>. If <em>n</em> is <code>npos</code>, then <em>ustr</em> is assumed to be null-terminated; else, <code>NULL</code> (<code>'\0'</code> ) characters have no special meaning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ustr</td><td>The source string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6873c4b0fd0cbb43b562b49efeb804cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UniChar&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>UniChar</code> constructor. </p>
<p>Creates a string that is initialised by <em>n</em> occurrences of character <em>c</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of occurrences of <em>c</em>. </td></tr>
    <tr><td class="paramname">c</td><td>The character to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a834590b2ba58aff33f8cb5bd989b84fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>wstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>std::wstring</code> constructor. </p>
<p>Creates a string that is initialised by, at most, the first <em>n</em> characters of <em>wstr</em> starting with index <em>pos</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>The source string. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the copy within the source string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17f7cad4fb6e93fa0b5ef9025e86fc43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wcstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>wchar_t</code> array constructor. </p>
<p>Creates a string that is initialised by, at most, the first <em>n</em> characters of <em>wcstr</em>. If <em>n</em> is <code>npos</code>, then <em>wcstr</em> is assumed to be null-terminated; else, <code>NULL</code> (<code>L'\0'</code> ) characters have no special meaning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wcstr</td><td>The source string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a059cf243258317190a6a955b6df22f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>kCFStringEncodingASCII</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>std::string</code> constructor. </p>
<p>Creates a string that is initialised by, at most, the first <em>n</em> characters of <em>sstr</em> starting with index <em>pos</em>. The source string is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The default value for <em>encoding</em> is <code>kCFStringEncodingASCII</code>. This allows the caller to pass in a string literal without having to worry about specifying an encoding. It also will be more likely to catch errors (erroneous encodings). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstr</td><td>The source string. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of the source string. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the copy within the source string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2795c89535e8e7f39ae22aebd9971374"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>kCFStringEncodingASCII</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>char*</code> array constructor. </p>
<p>Creates a string that is initialised by, at most, the first <em>n</em> characters of <em>cstr</em>. If <em>n</em> is <code>npos</code>, then <em>cstr</em> is assumed to be null-terminated; else, <code>NULL</code> (<code>'\0'</code> ) characters have no special meaning. The source string is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The default value for <em>encoding</em> is <code>kCFStringEncodingASCII</code>. This allows the caller to pass in a string literal without having to worry about specifying an encoding. It also will be more likely to catch errors (erroneous encodings). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cstr</td><td>The source string. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of the source string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to copy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acefb2813fdebb8225c5eb6755eaee834"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">ConstStringPtr&#160;</td>
          <td class="paramname"><em>pstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>kCFStringEncodingASCII</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pascal string constructor. </p>
<p>Creates a string that is initialised by <em>pstr</em>. The source string is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The default value for <em>encoding</em> is <code>kCFStringEncodingASCII</code>. This allows the caller to pass in a string literal without having to worry about specifying an encoding. It also will be more likely to catch errors (erroneous encodings). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstr</td><td>The source string. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of the source string. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0dda85fd2e7578a9b3700ce5f837605"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; UInt8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>external</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blob constructor. </p>
<p>Creates a string that is initialised by <em>blob</em>. The source string is assumed to be encoded using the character encoding given in <em>encoding</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>The source blob. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of <em>blob</em>. </td></tr>
    <tr><td class="paramname">external</td><td>If true, checks for BOM and performs byte-swapping as necessary. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e11aa572fa7246b4723ab829b170aad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1OSPtr.html">OSPtr</a>&lt; CFStringRef &gt; &amp;&#160;</td>
          <td class="paramname"><em>cfstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code><a class="el" href="classB_1_1OSPtr.html">OSPtr&lt;CFStringRef&gt;</a></code> constructor. </p>
<p>Creates a string as a copy of <em>cfstr</em>, using <em>cfstr's</em> allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The source string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1OSPtr.html#ad976d5f8b6b31bb0ff01eeb4cc4b90ef">B::OSPtr&lt; T &gt;::get()</a>.</p>

</div>
</div>
<a class="anchor" id="ae83d48f4091b7f2dac05b45af7f31288"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1OSPtr.html">OSPtr</a>&lt; CFMutableStringRef &gt; &amp;&#160;</td>
          <td class="paramname"><em>cfstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>OSPtr&lt;CFMutableStringRef&gt;</code> constructor. </p>
<p>Creates a string as a copy of <em>cfstr</em>, using <em>cfstr's</em> allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The source string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1OSPtr.html#ad976d5f8b6b31bb0ff01eeb4cc4b90ef">B::OSPtr&lt; T &gt;::get()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b50d6e9c5d4915a0156f345badfbda9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B::String::String </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFAllocatorRef&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Range constructor. </p>
<p>Creates a string that is initialised by all character of the range [<em>first</em>, <em>last</em>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range of characters for the new string. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of characters for the new string. </td></tr>
    <tr><td class="paramname">allocator</td><td>The new object's allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a34345998d4dfc32c8e54683af6c45ef7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>str</em>. </p>
<p>Compares the string <code>*this</code> with the string <em>str</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>str</em>; 0 if <code>*this</code> == <em>str</em>; &gt; 0 if <code>*this</code> &gt; <em>str</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to compare against. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>.</p>

<p>Referenced by <a class="el" href="group__MutableStringFunctions.html#ga97ff88d821549d6f4334ad69ebdc08a0">operator!=()</a>, <a class="el" href="group__MutableStringFunctions.html#ga1741af4f4076837c5e732789278da7db">B::operator!=()</a>, <a class="el" href="group__MutableStringFunctions.html#gae44236736216a76ffa77c5a7206c2511">operator&lt;()</a>, <a class="el" href="group__MutableStringFunctions.html#ga9775ca7980b7a8a2f0175f3594e04859">B::operator&lt;()</a>, <a class="el" href="group__MutableStringFunctions.html#ga34917218d8905a636d6b6b401c965757">operator&lt;=()</a>, <a class="el" href="group__MutableStringFunctions.html#ga095a21f4517d0c506cf3dfce810c0e43">B::operator&lt;=()</a>, <a class="el" href="group__MutableStringFunctions.html#gac7ed528200f695ceac3fde183f610cbf">operator==()</a>, <a class="el" href="group__MutableStringFunctions.html#ga45238b5892f4679cc9b28999d458b608">B::operator==()</a>, <a class="el" href="group__MutableStringFunctions.html#gae49c28125937cf2ab516cf2340b89f1d">operator&gt;()</a>, <a class="el" href="group__MutableStringFunctions.html#gaeeae5616bf4e6d50e466d0c7cce5cd47">B::operator&gt;()</a>, <a class="el" href="group__MutableStringFunctions.html#ga340adc39198284be157ac07980eb5791">operator&gt;=()</a>, and <a class="el" href="group__MutableStringFunctions.html#ga55cc31d79fb8fa4bbf2c85424aefed44">B::operator&gt;=()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b481ce9da0fbe3ade82edf1f918a0fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>str</em>. </p>
<p>Compares, at most, <em>n1</em> characters of string <code>*this</code>, starting with index <em>pos1</em> with string <em>str</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>str</em>; 0 if <code>*this</code> == <em>str</em>; &gt; 0 if <code>*this</code> &gt; <em>str</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The index of the first character to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">n1</td><td>The number of characters to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">str</td><td>The string to compare against. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>.</p>

</div>
</div>
<a class="anchor" id="ad488cebd5d1a4773c01ca081e779e70c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>str</em>. </p>
<p>Compares, at most, <em>n1</em> characters of string <code>*this</code>, starting with index <em>pos1</em> with, at most, <em>n2</em> characters of string <em>str</em> starting with index <em>pos2</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>str</em>; 0 if <code>*this</code> == <em>str</em>; &gt; 0 if <code>*this</code> &gt; <em>str</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>pos1</em> &gt; <code><a class="el" href="classB_1_1String.html#aa0b6379ad3d263696ab1bdfd07c120a1" title="Returns the number of characters in the string. ">size()</a></code> or <em>pos2</em> &gt; <em>str.size()</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The index of the first character to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">n1</td><td>The number of characters to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">str</td><td>The string to compare against. </td></tr>
    <tr><td class="paramname">pos2</td><td>The index of the first character to compare in <em>str</em>. </td></tr>
    <tr><td class="paramname">n2</td><td>The number of characters to compare in <em>str</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>.</p>

</div>
</div>
<a class="anchor" id="a46c057c992cfe329462d187682bf4e58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>cfstr</em>. </p>
<p>Compares the string <code>*this</code> with the string <em>cfstr</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>cfstr</em>; 0 if <code>*this</code> == <em>cfstr</em>; &gt; 0 if <code>*this</code> &gt; <em>cfstr</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The string to compare against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a55ec1252a7303e4cd777df4f22048a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>cfstr</em>. </p>
<p>Compares, at most, <em>n1</em> characters of string <code>*this</code>, starting with index <em>pos1</em> with string <em>cfstr</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>cfstr</em>; 0 if <code>*this</code> == <em>cfstr</em>; &gt; 0 if <code>*this</code> &gt; <em>cfstr</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>pos1</em> &gt; <code><a class="el" href="classB_1_1String.html#aa0b6379ad3d263696ab1bdfd07c120a1" title="Returns the number of characters in the string. ">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The index of the first character to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">n1</td><td>The number of characters to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">cfstr</td><td>The string to compare against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e5c92f07ef9da317261e8f5d3f53038"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>cfstr</em>. </p>
<p>Compares, at most, <em>n1</em> characters of string <code>*this</code>, starting with index <em>pos1</em> with, at most, <em>n2</em> characters of string <em>cfstr</em> starting with index <em>pos2</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>cfstr</em>; 0 if <code>*this</code> == <em>cfstr</em>; &gt; 0 if <code>*this</code> &gt; <em>cfstr</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>pos1</em> &gt; <code><a class="el" href="classB_1_1String.html#aa0b6379ad3d263696ab1bdfd07c120a1" title="Returns the number of characters in the string. ">size()</a></code> or <em>pos2</em> &gt; <code>CFStringGetLength</code>( <em>cfstr</em> ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The index of the first character to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">n1</td><td>The number of characters to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">cfstr</td><td>The string to compare against. </td></tr>
    <tr><td class="paramname">pos2</td><td>The index of the first character to compare in <em>cfstr</em>. </td></tr>
    <tr><td class="paramname">n2</td><td>The number of characters to compare in <em>cfstr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a582c097e41f7cd90f4aadd1f5c94595d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>ustr</em>. </p>
<p>Compares the string <code>*this</code> with the null-terminated <code>UniChar</code> array <em>ustr</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>ustr</em>; 0 if <code>*this</code> == <em>ustr</em>; &gt; 0 if <code>*this</code> &gt; <em>ustr</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ustr</td><td>The string to compare against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47fa80a190844b9ea3ab994f9be1fd72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>ustr</em>. </p>
<p>Compares, at most, <em>n1</em> characters of string <code>*this</code>, starting with index <em>pos1</em> with the null-terminated <code>UniChar</code> array <em>ustr</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>ustr</em>; 0 if <code>*this</code> == <em>ustr</em>; &gt; 0 if <code>*this</code> &gt; <em>ustr</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>pos1</em> &gt; <code><a class="el" href="classB_1_1String.html#aa0b6379ad3d263696ab1bdfd07c120a1" title="Returns the number of characters in the string. ">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The index of the first character to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">n1</td><td>The number of characters to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">ustr</td><td>The string to compare against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae446ce390a88d200aec8d982fb05bdde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>ustr</em>. </p>
<p>Compares, at most, <em>n1</em> characters of string <code>*this</code>, starting with index <em>pos1</em> with <em>n2</em> characters of <code>UniChar</code> array <em>ustr</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>ustr</em>; 0 if <code>*this</code> == <em>ustr</em>; &gt; 0 if <code>*this</code> &gt; <em>ustr</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>pos1</em> &gt; <code><a class="el" href="classB_1_1String.html#aa0b6379ad3d263696ab1bdfd07c120a1" title="Returns the number of characters in the string. ">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The index of the first character to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">n1</td><td>The number of characters to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">ustr</td><td>The string to compare against. </td></tr>
    <tr><td class="paramname">n2</td><td>The number of characters to compare in <em>ustr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb7ab9cecf4857db64b6d627fcc1d2d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>sstr</em>. </p>
<p>Compares the string <code>*this</code> with the string <em>sstr</em>, which is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>sstr</em>; 0 if <code>*this</code> == <em>sstr</em>; &gt; 0 if <code>*this</code> &gt; <em>sstr</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstr</td><td>The string to compare against. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of <em>sstr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab162083e902ab7c383157a11653a4243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>sstr</em>. </p>
<p>Compares, at most, <em>n1</em> characters of string <code>*this</code>, starting with index <em>pos1</em> with the string <em>sstr</em>, which is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>sstr</em>; 0 if <code>*this</code> == <em>sstr</em>; &gt; 0 if <code>*this</code> &gt; <em>sstr</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>pos1</em> &gt; <code><a class="el" href="classB_1_1String.html#aa0b6379ad3d263696ab1bdfd07c120a1" title="Returns the number of characters in the string. ">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The index of the first character to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">n1</td><td>The number of characters to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">sstr</td><td>The string to compare against. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of <em>sstr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfa11fb45d16fbaa5a2e1f053cc51647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the string to <em>sstr</em>. </p>
<p>Compares, at most, <em>n1</em> characters of string <code>*this</code>, starting with index <em>pos1</em> with, at most, <em>n2</em> characters of string <em>sstr</em> starting with index <em>pos2</em>. <em>Sstr</em> is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if <code>*this</code> &lt; <em>sstr</em>; 0 if <code>*this</code> == <em>sstr</em>; &gt; 0 if <code>*this</code> &gt; <em>sstr</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>pos1</em> &gt; <code><a class="el" href="classB_1_1String.html#aa0b6379ad3d263696ab1bdfd07c120a1" title="Returns the number of characters in the string. ">size()</a></code> or <em>pos2</em> &gt; <em>sstr.size()</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos1</td><td>The index of the first character to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">n1</td><td>The number of characters to compare in <code>*this</code>. </td></tr>
    <tr><td class="paramname">sstr</td><td>The string to compare against. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of <em>sstr</em>. </td></tr>
    <tr><td class="paramname">pos2</td><td>The index of the first character to compare in <em>str</em>. </td></tr>
    <tr><td class="paramname">n2</td><td>The number of characters to compare in <em>sstr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0551d7da3a456c96705c73afc7e08074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#ae1486fc75f7538e8de3185a8afc69079">String::const_reference</a> B::String::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the character at index <em>pos</em>. </p>
<p>If <em>pos</em> equals <code><a class="el" href="classB_1_1String.html#ac06622f8a89ce9cf3353563066607a49" title="Returns the number of characters in the string. ">length()</a></code>, the function returns '\0'. If <em>pos</em> is smaller than zero or greater than <code><a class="el" href="classB_1_1String.html#ac06622f8a89ce9cf3353563066607a49" title="Returns the number of characters in the string. ">length()</a></code>, the results are undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The index of the character to return. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#ac06622f8a89ce9cf3353563066607a49">length()</a>.</p>

</div>
</div>
<a class="anchor" id="a3647d17f9624fdcd97b62b75a7f3afea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#ae1486fc75f7538e8de3185a8afc69079">String::const_reference</a> B::String::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the character at index <em>pos</em>. </p>
<p>If <em>pos</em> is smaller than zero or greater than or equal to <code><a class="el" href="classB_1_1String.html#ac06622f8a89ce9cf3353563066607a49" title="Returns the number of characters in the string. ">length()</a></code>, the function throws an <code>std::out_of_range</code> exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, and <a class="el" href="classB_1_1String.html#aa0b6379ad3d263696ab1bdfd07c120a1">size()</a>.</p>

</div>
</div>
<a class="anchor" id="ab98caf544bf7fbc647686a4ef5708b82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::copy </td>
          <td>(</td>
          <td class="paramtype">UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the string to a <code>UniChar</code> array. </p>
<p>Copies at most <em>n</em> characters, starting at index <em>pos</em> in <code>*this</code>, into the buffer pointed to by <em>ustr</em>. No null character is appended.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of copied characters. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ustr</td><td>The output buffer. </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of characters to copy. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting index (in <code>*this</code>) for conversion. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="namespaceB.html#a62ca0c854c3403bb5c0b197314c0d9a8">B::CreateImageFromURL()</a>, <a class="el" href="classB_1_1ExceptionStringHolder.html#a69d444fdd1c99799ef08a9430252fd50">B::ExceptionStringHolder::GetString()</a>, <a class="el" href="classB_1_1HelpButton.html#a5c2e5e6ab425ab383b1d1fbea2440c70">B::HelpButton::Instantiate()</a>, <a class="el" href="classB_1_1InteractWithUserDialog.html#a7e3aa25277bccd268ef359c99b931d17">B::InteractWithUserDialog::InteractWithUserDialog()</a>, <a class="el" href="classB_1_1Document.html#af3f51da139e867f7bb79e8b51f5e9a15">B::Document&lt; UNDO_POLICY, PRINT_POLICY &gt;::MakeDocumentWriteStream()</a>, <a class="el" href="classB_1_1ExceptionStreamer.html#a970c86a85eddbb91e61431b9ae5baac6">B::ExceptionStreamer::Rethrow()</a>, <a class="el" href="structB_1_1ToolboxObjectPropertyTypeTrait.html#a7d4f69d0ed18580b88ca2945b5f749b7">B::ToolboxObjectPropertyTypeTrait&lt; T, OBJTR &gt;::Set()</a>, <a class="el" href="classB_1_1InteractWithUserDialog.html#a3e004ef689c05771915cfd549a2514d0">B::InteractWithUserDialog::SetText()</a>, and <a class="el" href="classB_1_1String.html#a205639c5a363a748eac55bbd4e95bc6f">Write()</a>.</p>

</div>
</div>
<a class="anchor" id="a31549acb4702ea1138817da9c61b44b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::copy </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>wcstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the string to a <code>wchar_t</code> array. </p>
<p>Copies at most <em>n</em> characters, starting at index <em>pos</em> in <code>*this</code>, into the buffer pointed to by <em>wcstr</em>. The string's characters are converted to <code>wchar_t</code> upon copying. No null character is appended.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of copied characters. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wcstr</td><td>The output buffer. </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of characters to copy. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting index (in <code>*this</code>) for conversion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a160f7b31d6a1c1f1dec6b434f7af3b85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::copy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>cstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies at most <em>n</em> bytes, starting at index <em>pos</em> in <code>*this</code>, into the buffer pointed to by <em>cstr</em>. </p>
<p>Copies at most <em>n</em> characters, starting at index <em>pos</em> in <code>*this</code>, into the buffer pointed to by <em>wcstr</em>. The string's characters are converted to <em>encoding</em> upon copying. No null character is appended.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of copied characters. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cstr</td><td>The output buffer. </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of characters to copy. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting index (in <code>*this</code>) for conversion. On output, holds the index of the next character to convert, or <code>npos</code> if conversion is complete. </td></tr>
    <tr><td class="paramname">encoding</td><td>The output buffer's encoding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab38d311bad371e0b12616742e487016b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void B::String::copy </td>
          <td>(</td>
          <td class="paramtype">CFMutableStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the string to a <code>CFMutableStringRef</code>. </p>
<p>The current contents of <em>cfstr</em> are completely replaced. If <code>cfstr</code> doesn't have enough capacity to hold the contents, the results are undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The output string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f377238c6696659cc9e881a5dfca48f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void B::String::copy </td>
          <td>(</td>
          <td class="paramtype">std::wstring &amp;&#160;</td>
          <td class="paramname"><em>wstr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the string to a <code>std::wstring</code>. </p>
<p>The string's characters are converted to <code>wchar_t</code> upon copying. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>The output string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac452366a48af4b0fff83685176c8bcb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void B::String::copy </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the string to a <code>std::string</code>. </p>
<p>The string's characters are converted to <em>encoding</em> upon copying. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstr</td><td>The output string. </td></tr>
    <tr><td class="paramname">encoding</td><td>The output string's encoding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affbb576944184ee2a0b4ced9c2122abb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void B::String::copy </td>
          <td>(</td>
          <td class="paramtype">StringPtr&#160;</td>
          <td class="paramname"><em>pstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the string to a Pascal <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>. </p>
<p>The string's characters are converted to <em>encoding</em> upon copying. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstr</td><td>The output string. </td></tr>
    <tr><td class="paramname">n</td><td>The maximum size of the output string, including length byte. </td></tr>
    <tr><td class="paramname">encoding</td><td>The output string's encoding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad21b1fc4a586145a9800bac87ae4a2e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void B::String::copy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; UInt8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>external</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>loss_byte</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the string to a blob. </p>
<p>If <em>external</em> is <code>true</code>, then the string is converted to an "external form", which usually means it is made suitable for writing to a file. In Unicode-speak, this implies prepending a BOM (Byte-Order Mark) character. The string's characters are converted to <em>encoding</em> upon copying. If <em>loss_byte</em> is non-zero, then any characters unconvertible to <em>encoding</em> will be replaced by <em>loss_byte</em>; else, conversion errors will cause an exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>The output buffer. </td></tr>
    <tr><td class="paramname">encoding</td><td>The output string's encoding. </td></tr>
    <tr><td class="paramname">external</td><td>If <code>true</code>, blob get a leading BOM. </td></tr>
    <tr><td class="paramname">loss_byte</td><td>The character to substitute for unconvertible characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37c912d8e45d861add183e8e6e36f5c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> assignemnt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>.</p>

</div>
</div>
<a class="anchor" id="ae3ad20be17741a6e6a632b83ecb62a48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1MutableString.html">MutableString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classB_1_1MutableString.html" title="Adapter class for changeable strings. ">MutableString</a> assignemnt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a83aeadbde60d5e1974f7e12615e09101"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>CFStringRef</code> assignemnt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71fc6fd6f830be76bf68e9502071f2df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1OSPtr.html">OSPtr</a>&lt; CFStringRef &gt; &amp;&#160;</td>
          <td class="paramname"><em>cfstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="classB_1_1OSPtr.html">OSPtr&lt;CFStringRef&gt;</a></code> assignemnt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1OSPtr.html#ad976d5f8b6b31bb0ff01eeb4cc4b90ef">B::OSPtr&lt; T &gt;::get()</a>.</p>

</div>
</div>
<a class="anchor" id="aee7418a7fae4aaca772a6f8240829d57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1OSPtr.html">OSPtr</a>&lt; CFMutableStringRef &gt; &amp;&#160;</td>
          <td class="paramname"><em>cfstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>OSPtr&lt;CFMutableStringRef&gt;</code> assignemnt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1OSPtr.html#ad976d5f8b6b31bb0ff01eeb4cc4b90ef">B::OSPtr&lt; T &gt;::get()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2f87e889ea15eb0e7b67f61f79227fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>UniChar</code> array assignemnt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ustr</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, <a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a0477f50762fb2645341af4bb84d436e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">UniChar&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>UniChar</code> assignemnt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The input character. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4a3f3ca8976e43991770c7bf89b4fc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>wstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>std::wstring</code> assignemnt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a3337b2d4349159ef6b005e48d95568ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wcstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Null-terminated <code>wchar_t</code> array assignemnt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wcstr</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, <a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a929206d4159eb85f9754f946b8272913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>std::string</code> assignemnt. </p>
<dl class="section note"><dt>Note</dt><dd>The input string is assumed to be encoded as <code>kCFStringEncodingASCII</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstr</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b35cd160ec1aa808ac9fa9ce19f3314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Null-terminated <code>char</code> array assignemnt. </p>
<dl class="section note"><dt>Note</dt><dd>The input string is assumed to be encoded as <code>kCFStringEncodingASCII</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cstr</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, <a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="aa0f8db96d79fe465f0f150292af911e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::operator= </td>
          <td>(</td>
          <td class="paramtype">ConstStringPtr&#160;</td>
          <td class="paramname"><em>pstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pascal string assignemnt. </p>
<dl class="section note"><dt>Note</dt><dd>The input string is assumed to be encoded as <code>kCFStringEncodingASCII</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstr</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a11338555c7c063655cba5148522e4737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a> assignemnt. </p>
<p>Assigns at most <em>n</em> characters of <em>str</em> starting with index <em>pos</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The input string. </td></tr>
    <tr><td class="paramname">pos</td><td>The index of the first character to assign from the input string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

<p>Referenced by <a class="el" href="classB_1_1ErrorHandler.html#a7cb5b6f77e6515b8c632583ce6479b55">B::ErrorHandler::AboutToThrow()</a>, <a class="el" href="classB_1_1String.html#aeaa409bbb99a71ba57303c239a3ffdb2">GetLine()</a>, <a class="el" href="classB_1_1View.html#a45d407847adc9c155f07ffbec182534d">B::View::GetText()</a>, <a class="el" href="classB_1_1Document.html#af3f51da139e867f7bb79e8b51f5e9a15">B::Document&lt; UNDO_POLICY, PRINT_POLICY &gt;::MakeDocumentWriteStream()</a>, <a class="el" href="classB_1_1NavReplyDialog_1_1PopupMenuItem.html#ac38081f292aa1f332b26d016dfc9040b">B::NavReplyDialog::PopupMenuItem::PopupMenuItem()</a>, <a class="el" href="classB_1_1String.html#ac947eb2bf39f17959d26f11c1305a83d">Read()</a>, <a class="el" href="structB_1_1ToolboxObjectPropertyTypeTrait.html#a7d4f69d0ed18580b88ca2945b5f749b7">B::ToolboxObjectPropertyTypeTrait&lt; T, OBJTR &gt;::Set()</a>, and <a class="el" href="classB_1_1TabbedView.html#af92615ae9f04799f949ee244ee11b81f">B::TabbedView::TabbedView()</a>.</p>

</div>
</div>
<a class="anchor" id="a00e4772d24fd4026bb9b3ead68a6293a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1MutableString.html">MutableString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classB_1_1MutableString.html" title="Adapter class for changeable strings. ">MutableString</a> assignemnt. </p>
<p>Assigns at most <em>n</em> characters of <em>str</em> starting with index <em>pos</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The input string. </td></tr>
    <tr><td class="paramname">pos</td><td>The index of the first character to assign from the input string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa70d880c9012fda01d9dfd30928410e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structB_1_1from__copy__t.html">from_copy_t</a> &amp;&#160;</td>
          <td class="paramname"><em>fc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>CFStringRef</code> assignemnt. </p>
<p>Assigns <em>cfstr</em> to this string. The input string's retain count is not incremented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The source string. </td></tr>
    <tr><td class="paramname">fc</td><td>An indication that <em>cfstr</em> comes from a Copy or Create function, and therefore that its retain count should not be increased. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a36b5cfa71803034b3c2f17fdeb3ed9fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nothrow_t &amp;&#160;</td>
          <td class="paramname"><em>nt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>CFStringRef</code> assignemnt. </p>
<p>Assigns <em>cfstr</em> to this string. If <em>cfstr</em> is <code>NULL</code>, use an empty string instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The source string. </td></tr>
    <tr><td class="paramname">nt</td><td>An indication that the function should not throw an exception if  is <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a45a1d498a4064264e6a6028c476fe099"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structB_1_1from__copy__t.html">from_copy_t</a> &amp;&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nothrow_t &amp;&#160;</td>
          <td class="paramname"><em>nt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>CFStringRef</code> assignemnt. </p>
<p>Assigns <em>cfstr</em> to this string. If <em>cfstr</em> is <code>NULL</code>, use an empty string instead. The input string's retain count is not incremented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The source string. </td></tr>
    <tr><td class="paramname">fc</td><td>An indication that <em>cfstr</em> comes from a Copy or Create function, and therefore that its retain count should not be increased. </td></tr>
    <tr><td class="paramname">nt</td><td>An indication that the function should not throw an exception if  is <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="aebca38136b748f38d5e512ad0714663d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>CFStringRef</code> assignemnt. </p>
<p>Assigns at most <em>n</em> characters of <em>cfstr</em> starting with index <em>pos</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The input string. </td></tr>
    <tr><td class="paramname">pos</td><td>The index of the first character to assign from the input string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f54d77a93398bbf9692c1c8c6f12cd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>UniChar</code> array assignemnt. </p>
<p>Assigns <em>n</em> characters of <em>ustr</em>. If <em>n</em> is <code>npos</code>, then <em>ustr</em> is assumed to be null-terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ustr</td><td>The input string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ad68fea2cff2ce9d18cbf0f9cdbd38407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UniChar&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>UniChar</code> assignemnt. </p>
<p>Assigns <em>num</em> occurrences of character <em>c</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of occurrences of <em>c</em>. </td></tr>
    <tr><td class="paramname">c</td><td>The character to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="adff509daa6e9a9eb22ec3b3b2b41ceed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>wstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>std::wstring</code> assignemnt. </p>
<p>Assigns at most <em>n</em> characters of <em>wstr</em> starting with index <em>pos</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>The input string. </td></tr>
    <tr><td class="paramname">pos</td><td>The index of the first character to assign from the input string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a4599d5c6015420577df35f6697346e27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wcstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>wchar_t</code> array assignemnt. </p>
<p>Assigns at most <em>n</em> characters of <em>wcstr</em> starting with index <em>pos</em>. If <em>n</em> is <code>npos</code>, then <em>wcstr</em> is assumed to be null-terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wcstr</td><td>The input string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="aa8a2f55f3b227fdad4e12bd20cdb0c17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>std::string</code> assignemnt. </p>
<p>Assigns at most <em>n</em> characters of <em>sstr</em> starting with index <em>pos</em>. The input string is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstr</td><td>The input string. </td></tr>
    <tr><td class="paramname">encoding</td><td>The input string's encoding. </td></tr>
    <tr><td class="paramname">pos</td><td>The index of the first character to assign from the input string. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a7cc6bd6912a5dd5f2bd78e02566840ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>char</code> array assignemnt. </p>
<p>Assigns at most <em>n</em> characters of <em>cstr</em> starting with index <em>pos</em>. If <em>n</em> is <code>npos</code>, then <em>cstr</em> is assumed to be null-terminated. The input string is assumed to be encoded using the character encoding given in <em>encoding</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cstr</td><td>The input string. </td></tr>
    <tr><td class="paramname">encoding</td><td>The input string's encoding. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ac55e0a26e7b6098dff787112b76523dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">ConstStringPtr&#160;</td>
          <td class="paramname"><em>pstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pascal string assignemnt. </p>
<p>The input string is assumed to be encoded using the character encoding given in <em>encoding</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstr</td><td>The input string. </td></tr>
    <tr><td class="paramname">encoding</td><td>The input string's encoding. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ae823dcf30a157afab9b4e22f93b49f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; UInt8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>external</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blob assignemnt. </p>
<p>Assigns the string from <em>blob</em>. The source string is assumed to be encoded using the character encoding given in <em>encoding</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>The source blob. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of <em>blob</em>. </td></tr>
    <tr><td class="paramname">external</td><td>If true, checks for BOM and performs byte-swapping as necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>, <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, <a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a>, <a class="el" href="classB_1_1OSPtr.html#a931d416d80f99efbd93b00c3ae33b84c">B::OSPtr&lt; T &gt;::release()</a>, <a class="el" href="classB_1_1OSPtr.html#a6a6c118332d7446d1d466ecd82f3e716">B::OSPtr&lt; T &gt;::reset()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a24c0927ec57e1cb74346019cc9260f7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> &amp; B::String::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range assignment. </p>
<p>Assigns the string with all character of the range [<em>first</em>, <em>last</em>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range of characters to assign. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of characters to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a3ad83f38a74d6918dc0bb3df5ef2e58c">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="acecd0740356538b01722f1cda338ed97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find </td>
          <td>(</td>
          <td class="paramtype">UniChar&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first occurrence of given character. </p>
<p>Searches for the first occurrence of the character <em>c</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of <em>c</em>, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a293044d03e79db8a516b2c27d43acbd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::rfind </td>
          <td>(</td>
          <td class="paramtype">UniChar&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last occurrence of given character. </p>
<p>Searches for the last occurrence of the character <em>c</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of <em>c</em>, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5ccc5704fa699f88a21261b78211b47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>. </p>
<p>Searches for the first occurrence of the string <em>str</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of <em>str</em>, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>.</p>

</div>
</div>
<a class="anchor" id="adf5c20d3f490cfe34f7103e443ae7f1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>. </p>
<p>Searches for the last occurrence of the string <em>str</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of <em>str</em>, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>.</p>

</div>
</div>
<a class="anchor" id="a6474660b9cc22ddcae69a16a462cb49b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first <code>CFStringRef</code>. </p>
<p>Searches for the first occurrence of the string <em>cfstr</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of <em>cfstr</em>, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9435942c1e4563c2bfaaf985335b5fd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::rfind </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last <code>CFStringRef</code>. </p>
<p>Searches for the last occurrence of the string <em>cfstr</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of <em>cfstr</em>, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d6d024f0988fb497b92ad75f2210808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find </td>
          <td>(</td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first <code>UniChar</code> array. </p>
<p>Searches for the first occurrence of the <code>UniChar</code> array <em>ustr</em> of length <em>n</em>, starting at index <em>pos</em>. If <em>n</em> equals <code>npos</code>, then <em>ustr</em> is assumed to be null-terminated.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of <em>sstr</em>, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ustr</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters in <em>ustr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7b7ec55290bc266241518c529cb9af2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::rfind </td>
          <td>(</td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last <code>UniChar</code> array. </p>
<p>Searches for the last occurrence of the <code>UniChar</code> array <em>ustr</em> of length <em>n</em>, starting at index <em>pos</em>. If <em>n</em> equals <code>npos</code>, then <em>ustr</em> is assumed to be null-terminated.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of <em>sstr</em>, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ustr</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters in <em>ustr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f9ff47b9414c208bcf56f26809e554e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first <code>std::string</code>. </p>
<p>Searches for the first occurrence of the string <em>sstr</em>, starting at index <em>pos</em>. The input string is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of <em>sstr</em>, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstr</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of <em>blob</em>. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad625cb77a3ff27ea7a04c2f174df3a00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::rfind </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last <code>std::string</code>. </p>
<p>Searches for the last occurrence of the string <em>sstr</em>, starting at index <em>pos</em>. The input string is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of <em>sstr</em>, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstr</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of <em>blob</em>. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb90141bdfc3759290317c9284cb2050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first character in a set given as a <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>. </p>
<p>Searches for the first occurrence of a character contained in <em>str</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>.</p>

</div>
</div>
<a class="anchor" id="aaaf37f8aa9d688c26c21e69a01cd756c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first character not in a set given as a <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>. </p>
<p>Searches for the first occurrence of a character <b>not</b> contained in <em>str</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d29fd0165f6f0937301136c705128c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_first_of </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first character in a set given as a <code>CFStringRef</code>. </p>
<p>Searches for the first occurrence of a character contained in <em>cfstr</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a1ecc5209d1954cee849ba0544138fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first character not in a set given as a <code>CFStringRef</code>. </p>
<p>Searches for the first occurrence of a character <b>not</b> contained in <em>cfstr</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4cffd38c1da37fd7d8468eb873b720d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first character in a set given as a <code>UniChar</code> array. </p>
<p>Searches for the first occurrence of a character contained in <em>ustr</em> of length <em>n</em>, starting at index <em>pos</em>. If <em>n</em> equals <code>npos</code>, then <em>ustr</em> is assumed to be null-terminated.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ustr</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters in <em>ustr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1540504694c22537145a1a768fdc0b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first character not in a set given as a <code>UniChar</code> array. </p>
<p>Searches for the first occurrence of a character <b>not</b> contained in <em>ustr</em> of length <em>n</em>, starting at index <em>pos</em>. If <em>n</em> equals <code>npos</code>, then <em>ustr</em> is assumed to be null-terminated.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ustr</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters in <em>ustr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ff1e369c4263c51e7a06d3faa659ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first character in a set given as a <code>std::string</code>. </p>
<p>Searches for the first occurrence of a character contained in <em>sstr</em>, starting at index <em>pos</em>. The input string is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstr</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of <em>blob</em>. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6086e541c67606533524f03e8b3101c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first character not in a set given as a <code>std::string</code>. </p>
<p>Searches for the first occurrence of a character <b>not</b> contained in <em>sstr</em>, starting at index <em>pos</em>. The input string is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstr</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of <em>blob</em>. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac074820eb53b4785d27cba6e56d8811f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last character in a set given as a <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>. </p>
<p>Searches for the last occurrence of a character contained in <em>str</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>.</p>

</div>
</div>
<a class="anchor" id="a063c81c7ff305f59ad2747dbefee1077"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classB_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last character not in a set given as a <a class="el" href="classB_1_1String.html" title="Adapter class for immutable strings. ">String</a>. </p>
<p>Searches for the last occurrence of a character <b>not</b> contained in <em>str</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>.</p>

</div>
</div>
<a class="anchor" id="a36b49e22e6da2a6e2c9a084d6911e796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_last_of </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last character in a set given as a <code>CFStringRef</code>. </p>
<p>Searches for the last occurrence of a character contained in <em>cfstr</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7229f34827b9b0f956d55a87c7c33335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">CFStringRef&#160;</td>
          <td class="paramname"><em>cfstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last character not in a set given as a <code>CFStringRef</code>. </p>
<p>Searches for the last occurrence of a character <b>not</b> contained in <em>cfstr</em>, starting at index <em>pos</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfstr</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5335835b08d4cda293016e2cf55dc3ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last character in a set given as a <code>UniChar</code> array. </p>
<p>Searches for the last occurrence of a character contained in <em>ustr</em> of length <em>n</em>, starting at index <em>pos</em>. If <em>n</em> equals <code>npos</code>, then <em>ustr</em> is assumed to be null-terminated.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ustr</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters in <em>ustr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ab242d0dac28bc427ed928be948d014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const UniChar *&#160;</td>
          <td class="paramname"><em>ustr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last character not in a set given as a <code>UniChar</code> array. </p>
<p>Searches for the last occurrence of a character <b>not</b> contained in <em>ustr</em> of length <em>n</em>, starting at index <em>pos</em>. If <em>n</em> equals <code>npos</code>, then <em>ustr</em> is assumed to be null-terminated.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ustr</td><td>The set of characters to look for. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters in <em>ustr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0c7575c6e99d9b6759ae30a0f735ad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last character in a set given as a <code>std::string</code>. </p>
<p>Searches for the last occurrence of a character contained in <em>sstr</em>, starting at index <em>pos</em>. The input string is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstr</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of <em>blob</em>. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa53c727945f5a2b07f5ca11b940027f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">String::size_type</a> B::String::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CFStringEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last character not in a set given as a <code>std::string</code>. </p>
<p>Searches for the last occurrence of a character <b>not</b> contained in <em>sstr</em>, starting at index <em>pos</em>. The input string is assumed to be encoded using the character encoding given in <em>encoding</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the found character, or <code>npos</code> if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstr</td><td>The string to look for. </td></tr>
    <tr><td class="paramname">encoding</td><td>The character encoding of <em>blob</em>. </td></tr>
    <tr><td class="paramname">pos</td><td>The starting position for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d8e1a930d0f6c05253b1447ad389609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classB_1_1String.html">String</a> B::String::substr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classB_1_1String.html#af754e00a7fd0be2c5fa859483e7e3bf5">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classB_1_1String.html#aeee24f0854e3bc2515fb2fa0b6e4ef44">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a substring. </p>
<p>Returns a substring of, at most, <em>n</em> characters of the string <code>*this</code> starting with index <em>pos</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The starting position for the substring. </td></tr>
    <tr><td class="paramname">n</td><td>The length of the substring. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classB_1_1String.html#a7bc1603f038cefd35c245a2f86ad46d0">cf_ref()</a>, <a class="el" href="classB_1_1String.html#a6f56a416adcc537505e0c0162b13c202">get_allocator()</a>, and <a class="el" href="classB_1_1String.html#a77389a7e45c336c0e695486d9e23b6b9">String()</a>.</p>

<p>Referenced by <a class="el" href="namespaceB.html#a288625c09c3700cc7ffa0bc5b514f563">B::GetDisplayName()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="BString_8h_source.html">BString.h</a></li>
<li>BString.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
