<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>B: Handling Carbon Events</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">B
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Handling Carbon Events </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="events"></a>
Events</h1>
<p>Carbon Events in <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> are represented by the <a class="el" href="classB_1_1Event.html" title="Template class representing a specific Carbon Event. ">Event</a> class template. Its two template parameters are the event's class and kind. <a class="el" href="classB_1_1Event.html" title="Template class representing a specific Carbon Event. ">Event</a> can act in both an incoming (i.e., received by you) and outgoing (i.e. sent by you) fashion. Although the template may be instantiated directly in simple cases, it is most often specialised. This allows each type of event to have specific member variables and functions.</p>
<p>Suppose you have defined your own event, and want to send it to an event target. You could do so like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyClass::MySendEvent(EventTargetRef target)</div><div class="line">{</div><div class="line">    <span class="comment">// construct a new event</span></div><div class="line">    <a class="code" href="classB_1_1Event.html">B::Event&lt;kMyEventClass, kMyEventKind&gt;</a> event;</div><div class="line">    </div><div class="line">    <span class="keyword">event</span>.<a class="code" href="classB_1_1EventBase.html#a5dba002b4c3798d074e4f423a9754a8e">Send</a>(target);</div><div class="line">}</div></div><!-- fragment --><p>And you would typically handle the event in a function like this one:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyClass::MyHandleEvent(<a class="code" href="classB_1_1Event.html">B::Event&lt;kMyEventClass, kMyEventKind&gt;</a>&amp; event)</div><div class="line">{</div><div class="line">    <span class="comment">// do stuff here...</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> (<span class="keyword">true</span>);  <span class="comment">// the event was handled</span></div><div class="line">}</div></div><!-- fragment --><p>Note the <code>bool</code> return type. All event handlers need to return <code>true</code> if they handled the event completely, or <code>false</code> otherwise. Returning <code>false</code> is equivalent to returning <code>eventNotHandledErr</code> from a C-style Carbon Event handler. If any other abnormal condition arises, the handler should throw an exception.</p>
<p>Of course, most of the interesting Carbon Events have parameters. Many of the system-defined Carbon Events already have template specialisations of <a class="el" href="classB_1_1Event.html" title="Template class representing a specific Carbon Event. ">Event</a>, and these specialisations take care of parameter addition and retrieval for you. For example, the <code>kEventClassCommand</code> / <code>kEventCommandProcess</code> event contains three parameters: the <code>HICommandExtended</code> struct, the key modifiers, and the menu context. Code to send one of these events to the user input focus could look like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyClass::MySendCmdEvent(<span class="keyword">const</span> HICommandExtended&amp; cmd)</div><div class="line">{</div><div class="line">    <span class="comment">// construct a new event with the proper parameters</span></div><div class="line">    <a class="code" href="classB_1_1Event.html">B::Event&lt;kEventClassCommand, kEventCommandProcess&gt;</a> event(cmd, 0, 0);</div><div class="line">    </div><div class="line">    <span class="keyword">event</span>.SendToUserFocus();</div><div class="line">}</div></div><!-- fragment --><p>Likewise, to handle the event:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyClass::MyHandleCmdEvent(<a class="code" href="classB_1_1Event.html">B::Event&lt;kEventClassCommand, kEventCommandProcess&gt;</a>&amp; event)</div><div class="line">{</div><div class="line">    UInt32 keyModifiers = <span class="keyword">event</span>.mKeyModifiers;</div><div class="line">    UInt32 menuContext  = <span class="keyword">event</span>.mMenuContext;</div><div class="line">    <span class="keywordtype">bool</span>   handled      = <span class="keyword">true</span>;</div><div class="line">    </div><div class="line">    <span class="keywordflow">switch</span> (event.mHICommand.commandID)</div><div class="line">    {</div><div class="line">        <span class="comment">// handle commands here...</span></div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> (handled);</div><div class="line">}</div></div><!-- fragment --><p>There are times when you need to set or get a parameter that for one reason or another isn't handled by an <a class="el" href="classB_1_1Event.html" title="Template class representing a specific Carbon Event. ">Event</a> specialisation. In that case you can use <a class="el" href="structB_1_1EventParam.html" title="Gets &amp; sets a specific Carbon Event parameter in a type-safe manner. ">EventParam</a> and related classes. <a class="el" href="structB_1_1EventParam.html" title="Gets &amp; sets a specific Carbon Event parameter in a type-safe manner. ">EventParam</a> maps its <code>NAME</code> template parameter onto an <code>EventParamType</code> and from there onto a C/C++ language type. It provides a very simple and type-safe way of accessing Carbon Event parameters:</p>
<div class="fragment"><div class="line">HIViewRef viewRef;</div><div class="line"><a class="code" href="classB_1_1Rect.html">B::Rect</a> bounds;</div><div class="line"><a class="code" href="classB_1_1Event.html">B::Event&lt;kEventClassControl, kEventControlGetOptimalBounds&gt;</a> event;</div><div class="line"></div><div class="line"><span class="comment">// Retrieve a parameter in a type-safe manner.</span></div><div class="line">bounds = <a class="code" href="structB_1_1EventParamAndType.html#ad28a33fe9accec36cd9e879d6e1ffc28">B::EventParam&lt;kEventParamControlOptimalBounds&gt;::Get</a>(event);</div><div class="line"></div><div class="line"><span class="comment">// Set a parameter in a type-safe manner.</span></div><div class="line"><a class="code" href="structB_1_1EventParamAndType.html#a0649ea89c13e54f03879dd8598d28588">B::EventParam&lt;kEventParamControlOptimalBounds&gt;::Set</a>(event, bounds);</div><div class="line"></div><div class="line"><span class="comment">// Set the direct parameter in a type-safe manner.</span></div><div class="line"><a class="code" href="structB_1_1EventParamAndType.html#a0649ea89c13e54f03879dd8598d28588">B::EventDirectParam&lt;typeControlRef&gt;::Set</a>(event, viewRef);</div><div class="line"></div><div class="line"><span class="comment">// Same as above, but wordier.</span></div><div class="line"><a class="code" href="structB_1_1EventParamAndType.html#a0649ea89c13e54f03879dd8598d28588">B::EventParamAndType&lt;kEventParamDirectObject, typeControlRef&gt;::Set</a>(event, viewRef);</div></div><!-- fragment --><p>The various "EventParam" classes are summarised below:</p>
<ul>
<li><a class="el" href="structB_1_1EventParamAndType.html" title="Gets &amp; sets a specific Carbon Event parameter of a specific type in a type-safe manner. ">EventParamAndType</a> is the class on which the others are built. It takes two template parameters, <code>NAME</code> and <code>TYPE</code>, which are of type <code>EventParamName</code> and <code>EventParamType</code>, respectively. The class maps the <code>TYPE</code> onto a C/C++ language type. This is the type used to get and set the parameter's value.</li>
<li><a class="el" href="structB_1_1EventParam.html" title="Gets &amp; sets a specific Carbon Event parameter in a type-safe manner. ">EventParam</a> is similar to <a class="el" href="structB_1_1EventParamAndType.html" title="Gets &amp; sets a specific Carbon Event parameter of a specific type in a type-safe manner. ">EventParamAndType</a> except that the <code>TYPE</code> template parameter is implicit in the <code>NAME</code> template parameter. Most Carbon Event parameters can only be of a single type, so the <code>NAME</code> indirectly determines the C/C++ language type of the parameter's value.</li>
<li><a class="el" href="structB_1_1EventDirectParam.html" title="Gets &amp; sets a Carbon Event&#39;s direct parameter in a type-safe manner. ">EventDirectParam</a> is similar to <a class="el" href="structB_1_1EventParamAndType.html" title="Gets &amp; sets a specific Carbon Event parameter of a specific type in a type-safe manner. ">EventParamAndType</a> except that the name is implicitly <code>kEventParamDirectObject</code>. This class is useful because <code>kEventParamDirectObject</code> is one of the few parameters whose type is overloaded; its type depends on the particular event.</li>
<li><a class="el" href="structB_1_1EventResultParam.html" title="Gets &amp; sets a Carbon Event&#39;s result parameter in a type-safe manner. ">EventResultParam</a> is similar to <a class="el" href="structB_1_1EventParamAndType.html" title="Gets &amp; sets a specific Carbon Event parameter of a specific type in a type-safe manner. ">EventParamAndType</a> except that the name is implicitly <code>kEventParamResult</code>. The rationale is the same as for <a class="el" href="structB_1_1EventDirectParam.html" title="Gets &amp; sets a Carbon Event&#39;s direct parameter in a type-safe manner. ">EventDirectParam</a>.</li>
</ul>
<h1><a class="anchor" id="event_handlers"></a>
Event Handlers</h1>
<p>The preceding section showed how to write a simple function that received an incoming Carbon Event, but it avoided discussing how that function could ever be called. That's where <a class="el" href="classB_1_1EventHandler.html" title="Holds a set of Carbon Event handlers for a given Carbon Event target. ">EventHandler</a> comes in.</p>
<p><a class="el" href="classB_1_1EventHandler.html" title="Holds a set of Carbon Event handlers for a given Carbon Event target. ">EventHandler</a> manages a collection of functions that each receive a specific Carbon Event. Each instance of <a class="el" href="classB_1_1EventHandler.html" title="Holds a set of Carbon Event handlers for a given Carbon Event target. ">EventHandler</a> is attached to a specific <code>EventTargetRef</code>. Adding an element to an <a class="el" href="classB_1_1EventHandler.html" title="Holds a set of Carbon Event handlers for a given Carbon Event target. ">EventHandler</a>'s collection can be done like this:</p>
<div class="fragment"><div class="line"><span class="comment">// A functor.</span></div><div class="line"><span class="keyword">struct </span>MyHandleEventFunctor {</div><div class="line">    <span class="keywordtype">bool</span> operator () (<a class="code" href="classB_1_1Event.html">B::Event&lt;kMyEventClass, kMyEventKind&gt;</a>&amp; event);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyInstallHandler(<a class="code" href="classB_1_1EventHandler.html">B::EventHandler</a>&amp; handler)</div><div class="line">{</div><div class="line">    <span class="comment">// Add the functor.</span></div><div class="line">    handler.<a class="code" href="classB_1_1EventHandler.html#a98ed10cc21a1e73601afc1eefd1fe123">Add</a>&lt;kMyEventClass, kMyEventKind&gt;(MyHandleEventFunctor());</div><div class="line">}</div></div><!-- fragment --><p>Of course, most of the time you will be setting up an <a class="el" href="classB_1_1EventHandler.html" title="Holds a set of Carbon Event handlers for a given Carbon Event target. ">EventHandler</a> to call member functions, not arbitrary functors.</p>
<p>Here is a fairly complete example. It shows management of an <a class="el" href="classB_1_1EventHandler.html" title="Holds a set of Carbon Event handlers for a given Carbon Event target. ">EventHandler</a> as a member variable of a class, and how to initialise it so member functions perform the event processing. <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a>'s own usage of <a class="el" href="classB_1_1EventHandler.html" title="Holds a set of Carbon Event handlers for a given Carbon Event target. ">EventHandler</a> isn't much more complex than this.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MyClass(EventTargetRef target);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// utility function to fill in the event handler.</span></div><div class="line">    <span class="keywordtype">void</span> InitEventHandler();</div><div class="line">    </div><div class="line">    <span class="comment">// the event handling function.</span></div><div class="line">    <span class="keywordtype">bool</span> MyHandleEvent(<a class="code" href="classB_1_1Event.html">B::Event&lt;kMyEventClass, kMyEventKind&gt;</a>&amp; event);</div><div class="line"></div><div class="line">    <span class="comment">// the event handler.</span></div><div class="line">    <a class="code" href="classB_1_1EventHandler.html">B::EventHandler</a> mEventHandler;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// The EventHandler member variable needs an EventTargetRef in its constructor.</span></div><div class="line">MyClass::MyClass(EventTargetRef target)</div><div class="line">    : mEventHandler(target)</div><div class="line">{</div><div class="line">    <span class="comment">// Tell the EventHandler which events we want to handle.</span></div><div class="line">    InitEventHandler();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyClass::InitEventHandler()</div><div class="line">{</div><div class="line">    <span class="comment">// When a kMyEventClass/kMyEventKind event is received, MyHandleEvent will </span></div><div class="line">    <span class="comment">// be called.  The first argument (&#39;this&#39;) is the object which will be </span></div><div class="line">    <span class="comment">// called -- in this case, ourselves.</span></div><div class="line">    mEventHandler.Add(<span class="keyword">this</span>, &amp;MyClass::MyHandleEvent);</div><div class="line">    </div><div class="line">    <span class="comment">// As an optimization, EventHandler starts off in a mode where it merely </span></div><div class="line">    <span class="comment">// builds up its collection of triples.  The Init() call actually </span></div><div class="line">    <span class="comment">// sets up the EventHandlerRef.</span></div><div class="line">    mEventHandler.Init();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> MyClass::MyHandleEvent(<a class="code" href="classB_1_1Event.html">B::Event&lt;kMyEventClass, kMyEventKind&gt;</a>&amp; event)</div><div class="line">{</div><div class="line">    <span class="comment">// do stuff</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> (<span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><p>Once you have an <a class="el" href="classB_1_1EventHandler.html" title="Holds a set of Carbon Event handlers for a given Carbon Event target. ">EventHandler</a> available, handling more events is a simple matter of declaring an event handling member function with the proper signature, then adding a call to <a class="el" href="classB_1_1EventHandler.html#a98ed10cc21a1e73601afc1eefd1fe123" title="Adds a handler that will invoke inFunctor in response to a Carbon Event of the given CLASS and KIND...">EventHandler::Add</a> during initialisation.</p>
<h1><a class="anchor" id="handler_chain"></a>
Event Propagation</h1>
<p>Unlike earlier application frameworks that originated on Classic Mac OS, such as MacApp and PowerPlant, <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> does not provide much functionality for routing Carbon Events to the right objects. This is because the Carbon Event mechanism now performs much of the work that used to be done by frameworks. <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> relies almost exclusively on the Carbon Event Manager's event propagation logic. This has two ramifications:</p>
<ol type="1">
<li>An entity that wants to participate in the propagation of events (eg to intercept some of them) needs to have an associated <code>EventTargetRef</code>. This is not a huge problem, since one can easily create new types of Carbon-Event-addressable objects by deriving from <a class="el" href="classB_1_1EventTarget.html" title="Base class for custom derivatives of HIObject. ">EventTarget</a>.</li>
<li>By default, events are propagated from the user input focus, up through any containing HIViews, to its owning WindowRef, and on to the application. Diverting the flow of events to some other, custom event target type requires some work. For an example, see <a class="el" href="classB_1_1DocumentWindow.html" title="Document-related window class. ">DocumentWindow</a>, which reroutes certain events to its owning <a class="el" href="classB_1_1Document.html" title="A concrete Document class. ">Document</a>. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
