<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>B: Exceptions and Error Handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">B
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Exceptions and Error Handling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Exceptions in the <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> framework are designed to be lightweight. They contain only the minimal amount of information required by upper layers of software to identify the problem. In particular, they do <b>not</b> contain textual messages meant for display to the user. There are two reasons for this. First, the throw site often doesn't have enough information about what the end user is trying to accomplish to formulate a meaningful message, to say nothing of internationalising and localising the message in the appropriate manner. Second, exception classes need to be robust, and the simpler they are, the smaller the chance that they will themselves introduce bugs (eg, throwing an exception while being constructed).</p>
<p><a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> contains a number of pre-defined exception classes. They are either general-purpose, or fill a very specific need in the framework. Examples of the former are <a class="el" href="classB_1_1FileNotFoundException.html" title="File-not-found exception class. ">FileNotFoundException</a> and <a class="el" href="classB_1_1OSStatusException.html" title="Abtract base class for exceptions containing a MacOS error code. ">OSStatusException</a>; an example of the latter is <a class="el" href="classB_1_1CharacterEncodingException.html" title="Character encoding exception class. ">CharacterEncodingException</a>.</p>
<h1><a class="anchor" id="throwing"></a>
Throwing Exceptions</h1>
<p>The code in <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> never throws directly; rather, it calls member functions of <a class="el" href="classB_1_1ErrorHandler.html" title="Centralised error handling. ">ErrorHandler</a> to perform the actual <code>throw</code>. This has the advantage of allowing code to be executed prior to any exception being thrown. Indeed, <a class="el" href="classB_1_1ErrorHandler.html" title="Centralised error handling. ">ErrorHandler</a> does exactly this by displaying an alert prior to throwing an exception (debug builds only). <a class="el" href="classB_1_1ErrorHandler.html" title="Centralised error handling. ">ErrorHandler</a>'s behaviour may be customised by subclassing, so the developer has the flexibility to for example, log all throws to a file or to a system log.</p>
<p>In order to shield the developer from the mechanics of this process, a number of convenience macros are available. They are the method of choice for throwing exceptions. For example:</p>
<ul>
<li>#B_THROW(ex) throws exception object <em>ex</em> (eg B_THROW(B::EOFException()) ).</li>
<li>#B_THROW_IF_NULL(p) throws <code>std::bad_alloc</code> if the pointer <em>p</em> is <code>NULL</code>.</li>
<li>#B_THROW_IF_NULL_RSRC(h) throws a Resource Manager exception if the handle <em>h</em> is <code>NULL</code>.</li>
<li>#B_THROW_IF(c, ex) is like #B_THROW(ex), but only throws if condition <em>c</em> is non-zero.</li>
<li>#B_THROW_STATUS(stat) throws an <a class="el" href="classB_1_1OSStatusException.html" title="Abtract base class for exceptions containing a MacOS error code. ">OSStatusException</a> with the value <em>stat</em>.</li>
<li>#B_THROW_IF_STATUS(stat) is like #B_THROW_STATUS(stat), but only throws if <em>stat</em> is non-zero. This is <b>very</b> convenient for testing the return value of "Classic" Mac OS functions.</li>
<li>#B_THROW_STATUS_IF(c, stat) is like #B_THROW_STATUS(stat), but only throws if condition <em>c</em> is non-zero.</li>
<li>#B_THROW_ERRNO_IF(c) throws an <a class="el" href="classB_1_1ErrnoException.html" title="BSD errno exception class. ">ErrnoException</a> with the current value of <code>errno</code> if condition <em>c</em> is non-zero. This is convenient for testing the return value of BSD functions that set <code>errno</code> internally but only return a success-failure indication.</li>
<li>#B_THROW_IF_ERRNO(errn) throws an <a class="el" href="classB_1_1ErrnoException.html" title="BSD errno exception class. ">ErrnoException</a> with the value <em>errn</em> if <em>errn</em> is non-zero. This is convenient for testing the return value of BSD functions that directly return an errno-style value, such as pthreads functions.</li>
</ul>
<p>Developers are encouraged to use these macros instead of using <code>throw</code> directly. Doing so will allow their throw sites to be integrated into <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a>'s error-handling infrastructure.</p>
<p>Also, developers should try to only throw objects of classes deriving from <code>std::exception</code>. Otherwise (i.e. throwing <code>OSStatus</code> codes or strings) the error-handling system loses a lot of functionality. Note that all of <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a>'s exception classes derive from <code>std::exception</code>.</p>
<h1><a class="anchor" id="catching"></a>
Catching Exceptions</h1>
<p>Catching exceptions in <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> works the same as in "vanilla" C++ code, however the way the exception classes are designed will affect the organisation of <code>catch</code> blocks. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyDoSomethingForUser()</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        <span class="comment">// do stuff</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (FileNotFoundException&amp; ex)</div><div class="line">    {</div><div class="line">        MyDisplayAlert(CFSTR(<span class="stringliteral">&quot;Couldn&#39;t locate the file&quot;</span>));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (IOException&amp; ex)</div><div class="line">    {</div><div class="line">        MyDisplayAlert(CFSTR(<span class="stringliteral">&quot;Couldn&#39;t open or read the file&quot;</span>));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (OSStatusException&amp; ex)</div><div class="line">    {</div><div class="line">        OSStatus err = ex.GetStatus();</div><div class="line">        </div><div class="line">        MyDisplayAlert(CFSTR(<span class="stringliteral">&quot;Got Mac OS error #%ld&quot;</span>), err);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">        MyDisplayAlert(CFSTR(<span class="stringliteral">&quot;I don&#39;t know what happened!&quot;</span>));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In the example above, the exception's type determines the action to take. It also allows the error-handling code to access type-specific members (eg, <code>GetStatus()</code> ) to retrieve additional information.</p>
<p>Although the example seems to have an excessive number of catch blocks, in practice often only a small number of exceptions are likely to occur with any frequency. The others can be handled with a catch-all block.</p>
<h1><a class="anchor" id="streaming"></a>
Streaming Exceptions</h1>
<p>Applications written with <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> are driven by two callback-based event systems: the Carbon Event Manager and the Apple Event Manager. Neither of these event systems has any built-in functionality for propagating C++ exceptions. On the contrary, exception propagation must be prevented with <code>catch (...)</code> prior to return.</p>
<p>Exacerbating this problem is the fact that <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> is designed to facilitate writing factored applications, in which UI-level code sends Apple Events to other parts of the application, which then perform the actual work. Obviously, the "actual work" is likely to be the place where most business-logic-related exceptions occur. So we have a situation where only very limited information (i.e. an <code>OSStatus</code> code and possibly a string) may be returned to the UI code, which is where an error message should be displayed to the user.</p>
<p>The solution adopted by <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> is to serialise the exception object into a data stream that is appended to the event (of either the Carbon or Apple variety). Upon return from the event-sending call, the exception is de-serialised and re-thrown. This allows exceptions to be thrown "through" either of the two managers without loss of information. The class that handles this process is <a class="el" href="classB_1_1ExceptionStreamer.html" title="Exception serialisation support. ">ExceptionStreamer</a>. It's a singleton, and typically developers don't need to deal with it directly very much, since the Carbon Event and Apple Event support classes do it already.</p>
<h1><a class="anchor" id="creating"></a>
Creating Exception Classes</h1>
<p>Creating exception classes in <a class="el" href="namespaceB.html" title="The B framework&#39;s namespace. ">B</a> is a two-step process: writing the class itself, and telling the exception-streaming infrastructure about it. Of course, if you don't care to have your exception class properly streamed through the Carbon Event and Apple Event managers, you can skip the second step. But that's unlikely.</p>
<p>The way that you "tell" the exception-streaming infrastructure about your exception class depends on how complex your class is. If it's simple, there is less to do. At the bottom of the complexity scale, we have exceptions that don't contain any state &ndash; i.e., the only information they contain is their type. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// MyExceptions.h</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MySimpleException : <span class="keyword">public</span> std::exception</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~MySimpleException() throw() {}  <span class="comment">// this is here to stop gcc from complaining</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* what() <span class="keyword">const</span> throw()     { <span class="keywordflow">return</span> <span class="stringliteral">&quot;MySimpleException&quot;</span>; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// MyExceptions.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;BExceptionStreamer.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;MyExceptions.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>{</div><div class="line">    <span class="keywordtype">bool</span> gRegSimpleEx = B::ExceptionStreamer::Register&lt;MySimpleException&gt;();</div><div class="line">}</div></div><!-- fragment --><p>The call to <a class="el" href="classB_1_1ExceptionStreamer.html#ac12023b486e1da525a8a2e1f756b4d92" title="Register class EXCEPTION for serialisation/deserialisation. ">ExceptionStreamer::Register&lt;MySimpleException&gt;()</a> tells the streaming infrastructure about our class. If we throw an exception of this type, the infrastructure will know that it doesn't need to extract any information from the exception object prior to returning to the operating system, and during de-serialisation will instantiate the exception object via its default constructor.</p>
<p>At the top of the complexity scale, we have exceptions capable of containing arbitrary state. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// MyExceptions.h</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyFloatException : <span class="keyword">public</span> std::exception</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span>    MyFloatException(<span class="keywordtype">float</span> f) <span class="keywordflow">throw</span>() : mFloat(f) {}</div><div class="line">    <span class="keyword">explicit</span>    MyFloatException(std::istream&amp; istr) { istr &gt;&gt; mFloat; }</div><div class="line">    <span class="keyword">virtual</span>     ~MyFloatException() throw()      {}</div><div class="line">    <span class="keywordtype">float</span>       GetFloat() <span class="keyword">const</span> throw()         { <span class="keywordflow">return</span> (mFloat); }</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* what() <span class="keyword">const</span> throw()             { <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyFloatException&quot;</span>; }</div><div class="line">    <span class="keywordtype">void</span>        Write(std::ostream&amp; ostr)<span class="keyword"> const  </span>{ ostr &lt;&lt; mFloat; }</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">float</span> mFloat;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>ExceptionTraits&lt;MyFloatException&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> StreamExceptionTag Category;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// MyExceptions.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;BExceptionStreamer.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;MyExceptions.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>{</div><div class="line">    <span class="keywordtype">bool</span> gRegFloatEx = B::ExceptionStreamer::Register&lt;MyFloatException&gt;();</div><div class="line">}</div></div><!-- fragment --><p>In this case, we tell <a class="el" href="classB_1_1ExceptionStreamer.html" title="Exception serialisation support. ">ExceptionStreamer</a> that this is a complex exception class by specialising the <a class="el" href="structB_1_1ExceptionTraits.html" title="Describes the characteristics of an exception class. ">ExceptionTraits</a> class template. <a class="el" href="structB_1_1ExceptionTraits.html" title="Describes the characteristics of an exception class. ">ExceptionTraits</a> serves as a means of categorising exception classes. It contains one typedef, <code>Category</code>, which maps to one of three types: <a class="el" href="structB_1_1DefaultExceptionTag.html" title="Tag describing exception classes that don&#39;t contain any state. ">DefaultExceptionTag</a>, <a class="el" href="structB_1_1StringExceptionTag.html" title="Tag describing exception classes whose state is a single string. ">StringExceptionTag</a> or <a class="el" href="structB_1_1StreamExceptionTag.html" title="Tag describing exception classes that contain complex state. ">StreamExceptionTag</a>. The default value is <a class="el" href="structB_1_1DefaultExceptionTag.html" title="Tag describing exception classes that don&#39;t contain any state. ">DefaultExceptionTag</a>, which is used by simple exception classes.</p>
<p>By typedef'ing <a class="el" href="structB_1_1ExceptionTraits.html#ab1e9a9c18a0517d6cf2091e3eeaa9dfe" title="Describes how to retrieve and construct the exception&#39;s state. ">ExceptionTraits&lt;MyFloatException&gt;::Category</a> to <a class="el" href="structB_1_1StreamExceptionTag.html" title="Tag describing exception classes that contain complex state. ">StreamExceptionTag</a>, we instruct <a class="el" href="classB_1_1ExceptionStreamer.html" title="Exception serialisation support. ">ExceptionStreamer</a> to (1) retrieve the exception's state by calling the <code>Write()</code> member function, passing it an <code>std::ostream</code>; and (2) to construct the exception after de-serialisation via a constructor taking an <code>std::istream</code>.</p>
<p>There is also an intermediate level of complexity for exception classes. It's for cases where the exception's state is completely described by its <code>what()</code> string. For such cases, <a class="el" href="structB_1_1ExceptionTraits.html#ab1e9a9c18a0517d6cf2091e3eeaa9dfe" title="Describes how to retrieve and construct the exception&#39;s state. ">ExceptionTraits&lt;&gt;::Category</a> should be typedef'd to <a class="el" href="structB_1_1StringExceptionTag.html" title="Tag describing exception classes whose state is a single string. ">StringExceptionTag</a>. The exception's state will be retrieved by calling <code>what()</code>, and the exception object will be re-instantiated via a constructor taking a <code>const std::string</code>.</p>
<h1><a class="anchor" id="error_handling"></a>
Custom Error Handling</h1>
<p>As mentionned above, the ThrowXXX() macros end up calling member functions of <a class="el" href="classB_1_1ErrorHandler.html" title="Centralised error handling. ">ErrorHandler</a>, specifically <a class="el" href="classB_1_1ErrorHandler.html#a7cb5b6f77e6515b8c632583ce6479b55" title="This is called before throwing exception ex in debug builds. ">ErrorHandler::AboutToThrow()</a> and <a class="el" href="classB_1_1ErrorHandler.html#a8b4a6bf9879bf9109be0356e40a93f7c" title="This is called when an assertion fails in debug builds. ">ErrorHandler::AssertionFailed()</a>. The default implementations of these functions display an alert in debug builds. There are three ways of changing this behaviour.</p>
<p>First, the developer can control the amount of information displayed in the exception-thrown alert by defining the <code>B_DETAILED_EXCEPTION_INFO</code> macro. By default, it is non-zero in debug builds and zero in release builds. Setting <code>B_DETAILED_EXCEPTION_INFO</code> to a non-zero value (eg in a prefix file) will cause detailed exception info (file name, line number, and function name) to always be generated when an exception is thrown, even in release builds. Of course, generating this information will make your executable larger. The <code>B_DETAILED_ASSERT_INFO</code> macro works in the same way, except that if it is zero no asserts are generated at all.</p>
<p>Second, the developer can control the display of alerts at runtime by changing each alert's "quiet flag". The quiet flags are a hint to <code>AboutToThrow()</code> and <code>AssertionFailed()</code> as to whether they should display alerts or not. The flags may be queried via <a class="el" href="classB_1_1ErrorHandler.html#aa3cd6e9a5cee8716a0a842e6bb9d4cf2" title="Returns the quiet flag for throws. ">ErrorHandler::GetQuietThrows()</a> and <a class="el" href="classB_1_1ErrorHandler.html#a047a5ac4b045517b98c2191336ed0035" title="Returns the quiet flag for asserts. ">ErrorHandler::GetQuietAsserts()</a>, and changed via <a class="el" href="classB_1_1ErrorHandler.html#a95124b1c8dc5e184ebc32d9d995a72c9" title="Changes the quiet flag for throws. ">ErrorHandler::SetQuietThrows()</a> and <a class="el" href="classB_1_1ErrorHandler.html#ad6ab4212a8eb6ee82cf6c71f6a0e28ae" title="Changes the quiet flag for asserts. ">ErrorHandler::SetQuietAsserts()</a>.</p>
<p>Third, the developer may replace the current error handler by any object derived from <a class="el" href="classB_1_1ErrorHandler.html" title="Centralised error handling. ">ErrorHandler</a>. The implementations of <code>AboutToThrow()</code> and <code>AssertionFailed()</code> will be under the developer's complete control, so they can do pretty much anything. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyErrorHandler : <span class="keyword">public</span> <a class="code" href="classB_1_1ErrorHandler.html">B::ErrorHandler</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    MyErrorHandler(std::ostream&amp; ostr) : mStream(ostr) {}</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> AboutToThrow(</div><div class="line">        <span class="keyword">const</span> std::exception&amp; ex,</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>*           file,</div><div class="line">        <span class="keywordtype">int</span>                   line,</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>*           func)</div><div class="line">    {</div><div class="line">        mStream &lt;&lt; <span class="stringliteral">&quot;exception &quot;</span> &lt;&lt; ex.what() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; line</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; func &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">    std::ostream&amp; mStream;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyInstallErrorHandler()</div><div class="line">{</div><div class="line">    <a class="code" href="classB_1_1ErrorHandler.html#ab04229ec6d388182b990d5e325050e13">ErrorHandler::Set</a>(<span class="keyword">new</span> MyErrorHandler(std::cout));</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="classB_1_1ErrorHandler.html" title="Centralised error handling. ">ErrorHandler</a> is a per-thread singleton, meaning that each thread gets its own distinct <a class="el" href="classB_1_1ErrorHandler.html" title="Centralised error handling. ">ErrorHandler</a> object. <a class="el" href="classB_1_1ErrorHandler.html#ab04229ec6d388182b990d5e325050e13" title="Changes the ErrorHandler instance for the current thread. ">ErrorHandler::Set()</a> only changes the error handler for the current thread, just as <a class="el" href="classB_1_1ErrorHandler.html#addef6667d57422d3b4cf80fdd31ca069" title="Returns the ErrorHandler instance for the current thread. ">ErrorHandler::Get()</a> returns the current thread's error handler. This means you can use the default implementation in the main thread (where displaying an alert makes sense), and a custom logging implementation in other threads. Note that there is no concurrency control of any kind around calls to <code>AboutToThrow()</code> and <code>AssertionFailed()</code>, so the above example would probably not give the expected results in a multi-threaded app (the output from multiple threads might be interleaved). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
